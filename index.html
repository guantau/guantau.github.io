<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="imtau">
<meta property="og:url" content="http://blog.guantau.com/index.html">
<meta property="og:site_name" content="imtau">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="imtau">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.guantau.com/"/>

  <title> imtau </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f5a1bfbe590ec34a0aac4a5c7965a30d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">imtau</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/08/byteball-private-communication/" itemprop="url">
                  ByteBall加密通信原理解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-08T17:30:55+08:00" content="2018-08-08">
              2018-08-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/08/08/byteball-private-communication/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/08/byteball-private-communication/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/08/08/byteball-private-communication/" class="leancloud_visitors" data-flag-title="ByteBall加密通信原理解析">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ByteBall网络中提供了端到端的加密通道，可以实现用户设备之间的加密通信，从而用于发送加密文本消息、发送隐私资产、进行多签名交易、签订智能合约、提供机器人服务等。下面我们将对ByteBall中加密通信实现的基本思路和主要过程进行解析。</p>
<h2 id="加密通信基本思路"><a href="#加密通信基本思路" class="headerlink" title="加密通信基本思路"></a>加密通信基本思路</h2><p>从功能的角度来看，加密通道采用存储-转发的方式来实现，这个任务由Hub来完成。消息发送方将加密消息发送到Hub，Hub再将消息转发给接收方。网络中可以存在多个Hub，用户设备可以选择自己信任的Hub进行连接。从这个角度看，Hub在设备加密通信中扮演的角色类似于邮件服务器。用户设备使用其设备地址在Hub上进行注册，生成类似邮件地址进行通信，比如<code>device_pubkey@hub.domainname.com</code>。<code>device_pubkey</code>是由设备地址的公钥，当用户设备在不同的Hub之间切换时，<code>device_pubkey</code>保持不变。有一点需要注意的是，Hub之间不会进行消息中继，用户设备只有连接到相同Hub上才可以进行通信。</p>
<p>从安全的角度来看，用户设备与Hub之间的传输通道、用户设备与设备之间的传输内容均采用了加密。用户设备与Hub之间采用websocket保持连接，连接采用TLS加密。用户设备发送的消息内容采用ECDH+AES进行加密，并采用ECDSA进行签名验证。由于发送的消息是采用端到端加密的，Hub作为唯一的中间方也是无法查看或者修改其内容的。当消息发送成功后，Hub会删除相应的消息，且不保存任何副本。此外，为了进一步确保转发安全，用户设备还会定期更新其加密公钥（称为临时公钥）。</p>
<h2 id="加密通信主要过程"><a href="#加密通信主要过程" class="headerlink" title="加密通信主要过程"></a>加密通信主要过程</h2><h3 id="设备登录Hub"><a href="#设备登录Hub" class="headerlink" title="设备登录Hub"></a>设备登录Hub</h3><p>当用户设备连接到Hub时，Hub会向其发送一个登录验证消息<code>hub/challenge</code>，包括一个长度为30的BASE64编码的字符串。随后，用户设备会向Hub发送登录消息<code>hub/login</code>，包括Hub发送的登录字符串、永久公钥和临时公钥。</p>
<p>当用户设备的永久私钥、临时私钥或者连接的Hub地址发生变化时，都需要重新发起登录过程。用户设备采用<code>hub/temp_pubkey</code>每分钟向Hub更新自己的临时公钥。当设备登录Hub后<code>hub/login</code>或者刷新消息时<code>hub/refresh</code>，可以从Hub获取消息状态<code>hub/message_box_status</code>。</p>
<h3 id="建立加密通道"><a href="#建立加密通道" class="headerlink" title="建立加密通道"></a>建立加密通道</h3><p>在发送方连接到接收方所在的Hub完成登录过程后，设备之间进行加密通信主要包括以下几个步骤：</p>
<ol>
<li>从Hub获取接收方的临时公钥（使用<code>hub/get_temp_pubkey</code>）；</li>
<li>发送方生成一次性的消息加密钥匙对（包含私钥及公钥）；</li>
<li>通过接收方临时公钥和刚生成的一次性私钥得到ECDH共享密钥；</li>
<li>利用ECDH共享密钥对消息内容进行AES加密；</li>
<li>发送方将加密后的消息内容、初始向量、一次性公钥打包为数据包；</li>
<li>采用设备永久公钥对数据包进行签名；</li>
<li>采用<code>hub/deliver</code>向Hub发送数据包。</li>
</ol>
<p>Hub收到发送方的数据包后，向接收方采用<code>hub/message</code>转发数据包，从而建立起发送方与接收方之间的加密通道，即发送方的消息可通过加密通道到达接收方。</p>
<p>当接收方Hub无法连接时，发送方将待发送消息采用接收方的永久公钥加密并本地存储。当接收方Hub可以连接时，发送方将存储的加密消息再使用接收方的临时公钥进行二次加密，然后再发送给对方。这样可以保证在发送方的数据库中不存储明文消息。</p>
<h3 id="设备配对"><a href="#设备配对" class="headerlink" title="设备配对"></a>设备配对</h3><p>在建立起设备之间的加密通道后，设备之间还需要进行配对（或者称为认证）才能正式开始通信。配对发起方需要已知对方的地址及配对字符串，格式为<code>device_pubkey@hub.domainname.com#randomstring</code>，其中<code>device_pubkey</code>为设备地址公钥、<code>hub.domainname.com</code>为Hub地址、<code>randomstring</code>为配对字符串。设备配对主要用来获取对方设备的名称、公钥、地址及所在Hub，同时对对方身份进行验证。配对的设备存储在数据表<code>correspondent_devices</code>中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>设备之间配对完成后就可以通过加密通道进行通信，对于加密消息的处理集中在<code>byteballcore/wallet.js</code>中的<code>handleMessageFromHub</code>函数中。用户设备之间的加密通信能力赋予了ByteBall钱包极其灵活及多样的功能，是ByteBall系统设计中非常重要的一个组成部分。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/26/byteball-wallet2/" itemprop="url">
                  再论ByteBall钱包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-26T12:42:55+08:00" content="2018-06-26">
              2018-06-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/26/byteball-wallet2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/26/byteball-wallet2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/06/26/byteball-wallet2/" class="leancloud_visitors" data-flag-title="再论ByteBall钱包">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ByteBall的钱包类型分为两种：</p>
<ol>
<li>单设备钱包：该类型钱包仅由单一设备控制，它与特定设备地址是绑定的，钱包中的地址为单签名地址；</li>
<li>多设备钱包：该类型钱包由多个设备共同控制，它与若干个设备地址绑定，钱包中的地址为多签名地址。</li>
</ol>
<p>在之前的文章<a href="https://bbfans.org/2018/06/17/byteball%E9%92%B1%E5%8C%85%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《ByteBall钱包详解》</a>中，我们提到，ByteBall的地址分为三种：</p>
<ol>
<li>普通地址：地址定义中不包含其它地址，采用BASE32编码，长度为32，比如<code>A2WWHN7755YZVMXCBLMFWRSLKSZJN3FU</code>；</li>
<li>共享地址：地址定义中包含了其它地址，地址格式与普通地址相同，通常用作智能合约地址；</li>
<li>设备地址：生成方法及地址格式类似普通地址，但在设备地址在头部添加了一个0，长度为33，比如<code>05FV4WNIEU4OHIAIF7XEIRC2QRRLFPAC3</code>。</li>
</ol>
<p>因此，ByteBall的钱包与地址可以总结为下面这张图：</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-06-25-144238.png" alt="byteball-wallet"></p>
<p>其中：设备具有唯一的设备地址；普通地址包括单签名地址和多签名地址，单设备钱包生成单签名地址，多设备钱包生成多签名地址；多个普通地址可以共同构成共享地址。</p>
<h2 id="单签名地址"><a href="#单签名地址" class="headerlink" title="单签名地址"></a>单签名地址</h2><p>单设备钱包由单一设备生成，假设设备地址为<code>DEVICE_ADDRESS</code>，单设备钱包中单签名地址定义的模板为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">["sig", &#123;pubkey: '$pubkey@DEVICE_ADDRESS'&#125;]</span><br></pre></td></tr></table></figure>
<p>具体在生成地址时，<code>$pubkey@DEVICE_ADDRESS</code>会替换成相应的公钥。</p>
<h2 id="多签名地址"><a href="#多签名地址" class="headerlink" title="多签名地址"></a>多签名地址</h2><p>多设备钱包由多个设备共同控制。假设3个设备的地址分别为<code>DEVICE_A_ADDRESS</code>、<code>DEVICE_B_ADDRESS</code>以及<code>DEVICE_C_ADDRESS</code>。我们需要生成一个<code>2-3</code>的多设备钱包，即3个设备中至少需要2个设备签名才可以生效，则相应的多设备钱包中多签名地址定义的模板为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"r of set"</span>, &#123;</span><br><span class="line">    required: 2,</span><br><span class="line">    set: [</span><br><span class="line">        ["sig", &#123;pubkey: '$pubkey@DEVICE_A_ADDRESS'&#125;],</span><br><span class="line">        ["sig", &#123;pubkey: '$pubkey@DEVICE_B_ADDRESS'&#125;],</span><br><span class="line">        ["sig", &#123;pubkey: '$pubkey@DEVICE_C_ADDRESS'&#125;],</span><br><span class="line">    ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>在创建多设备钱包时，设备之间会通过加密消息相互交换<code>xPubKey</code>。这样，不同的设备可以依据相同的地址路径生成相同的地址。</p>
<h2 id="共享地址"><a href="#共享地址" class="headerlink" title="共享地址"></a>共享地址</h2><p>共享地址本质上可以认为是智能合约的地址，例如<code>flight delay insurance</code>的地址定义（或者智能合约）示例为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>,[</span><br><span class="line">    [<span class="string">"and"</span>,[</span><br><span class="line">       [<span class="string">"seen"</span>,&#123;<span class="attr">"what"</span>:<span class="string">"output"</span>,<span class="attr">"address"</span>:<span class="string">"this address"</span>,<span class="attr">"asset"</span>:<span class="string">"base"</span>,<span class="attr">"amount"</span>:<span class="number">22664</span>&#125;],</span><br><span class="line">       [<span class="string">"or"</span>,[</span><br><span class="line">           [<span class="string">"and"</span>,[</span><br><span class="line">               [<span class="string">"address"</span>,<span class="string">"TTD2AVY4W2VH62NJXIP7R67XBHWZRQRJ"</span>],</span><br><span class="line">               [<span class="string">"in data feed"</span>,[[<span class="string">"GFK3RDAPQLLNCMQEVGGD2KCPZTLSG3HN"</span>],<span class="string">"MU5152-2018-06-18"</span>,<span class="string">"&gt;"</span>,<span class="string">"60"</span>,<span class="number">2810590</span>]]]],</span><br><span class="line">           [<span class="string">"and"</span>,[</span><br><span class="line">               [<span class="string">"address"</span>,<span class="string">"4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span>],</span><br><span class="line">               [<span class="string">"in data feed"</span>,[[<span class="string">"I2ADHGP4HL6J37NQAD73J7E5SKFIXJOT"</span>],<span class="string">"timestamp"</span>,<span class="string">"&gt;"</span>,<span class="number">1529442000000</span>]]]],</span><br><span class="line">           [<span class="string">"and"</span>,[</span><br><span class="line">               [<span class="string">"address"</span>,<span class="string">"4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span>],</span><br><span class="line">               [<span class="string">"in data feed"</span>,[[<span class="string">"GFK3RDAPQLLNCMQEVGGD2KCPZTLSG3HN"</span>],<span class="string">"MU5152-2018-06-18"</span>,<span class="string">"&lt;="</span>,<span class="string">"60"</span>,<span class="number">2810590</span>]]]]]]]],</span><br><span class="line">    [<span class="string">"and"</span>,[</span><br><span class="line">        [<span class="string">"address"</span>,<span class="string">"4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span>],</span><br><span class="line">        [<span class="string">"not"</span>,[<span class="string">"seen"</span>,&#123;<span class="attr">"what"</span>:<span class="string">"output"</span>,<span class="attr">"address"</span>:<span class="string">"this address"</span>,<span class="attr">"asset"</span>:<span class="string">"base"</span>,<span class="attr">"amount"</span>:<span class="number">22664</span>&#125;]],</span><br><span class="line">        [<span class="string">"in data feed"</span>,[[<span class="string">"I2ADHGP4HL6J37NQAD73J7E5SKFIXJOT"</span>],<span class="string">"timestamp"</span>,<span class="string">"&gt;"</span>,<span class="number">1529034037936</span>]]]]]</span><br></pre></td></tr></table></figure>
<p>上述地址定义中共涉及到两个地址<code>TTD2AVY4W2VH62NJXIP7R67XBHWZRQRJ</code>及<code>4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ</code>，它是这两个地址的共享地址。</p>
<p>通过上述地址定义，可以得到该共享地址为<code>WDCIIWRDHSNNE2DQZ7YVU53USELZBLGV</code>。其中，地址的签名路径包括：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    r.0.1.0.0: "TTD2AVY4W2VH62NJXIP7R67XBHWZRQRJ",</span><br><span class="line">    r.0.1.1.0: "4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span><br><span class="line">    r.0.1.2.0: "4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span><br><span class="line">    r.1.0: "4JZOKE43GALLZA4P63NXT7NYAJLSMNYZ"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有满足合约中相应的条件，且具有相应路径的签名，才可以对共享地址中的资产进行操作。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/15/byteball-wallet/" itemprop="url">
                  ByteBall钱包详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-15T23:48:55+08:00" content="2018-06-15">
              2018-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/15/byteball-wallet/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/15/byteball-wallet/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/06/15/byteball-wallet/" class="leancloud_visitors" data-flag-title="ByteBall钱包详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="钱包结构"><a href="#钱包结构" class="headerlink" title="钱包结构"></a>钱包结构</h2><p>顾名思义，钱包是用来保存钱的。但在数字货币的世界中，钱包里面并没有“钱”。钱包账户里有多少“钱”都是记录在区块链上的，钱包里只是存储了账户对应的<strong>私钥</strong>，账户是从私钥相应的公钥衍生出来的。只要有了私钥，你就可以在数字货币世界里证明你的身份，发送区块链上属于你的资产。因此，<strong>钱包实际上是管理和存储私钥的工具</strong>。</p>
<p>ByteBall钱包结构与Bitcoin类似，Bitcoin对管理和存储私钥以及通过私钥生成地址制定了一系列标准（BIP, Bitcoin Improvement Proposals），主要包括：</p>
<ul>
<li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener">BIP32</a>：定义了HD钱包（Hierarchical Deterministic Wallet），允许从单一种子产生一树状结构储存多组私钥和公钥，可以方便的备份、转移以及分层权限控制等。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。下图展示了HD钱包的树状结构：</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-06-17-082216.png" alt="bip33-hd-wallet"></p>
</li>
<li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">BIP39</a>：将种子用方便记忆和书写的单词表示，一般由12个单词组成，称为助记词或助记码。由一系列单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入。比如<code>shrimp make call path pink draw gym song select brother social base</code>，其相应的私钥为<code>xprv9s21ZrQH143K4HQ8sBPNNkXHNuVYfivR96gtpJzMWCJVF5hdYjzT5nVQu6GfHAQLPstQtFp9GTWADUcKgzaV5EyL5JxT2rxkyg51ReGTVg8</code>。</p>
</li>
<li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki" target="_blank" rel="noopener">BIP43</a>：为HD钱包路径引入<code>purpose</code>字段，路径记作<code>m / purpose&#39; / *</code>，比如<code>m / 0&#39; / *</code>表示BIP32的默认账户。</p>
</li>
<li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank" rel="noopener">BIP44</a>：定义HD钱包路径字段，赋予树状结构中的各层特殊的意义，从而支持多币种、多账户，路径定义为：</p>
<p><code>m / purpose&#39; / coin_type&#39; / account&#39; / change / address_index</code></p>
<p>其中，<code>purpose&#39;</code>固定是<code>44&#39;</code>，代表使用BIP44；<code>coin_type&#39;</code>用来表示不同币种，例如Bitcoin就是<code>0&#39;</code>，Bitcoin Testnet是<code>1&#39;</code>，Ethereum是<code>60&#39;</code>；<code>account&#39;</code>表示账户编码；<code>change</code>用来表示该地址是否为找零地址；<code>address_index</code>为地址编号。</p>
</li>
<li><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki" target="_blank" rel="noopener">BIP45</a>：定义多签名HD钱包路径字段，从而支持多签名地址，路径定义为：</p>
<p><code>m / purpose&#39; / cosigner_index / change / address_index</code></p>
<p>其中，<code>purpose</code>固定是<code>45&#39;</code>，代表使用BIP45；<code>cosigner_index</code>表示多签名用户编号；其余字段与BIP44相同。</p>
</li>
</ul>
<p>ByteBall钱包采用的是符合BIP44标准的HD钱包，其采用的路径结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m / 44&apos; / 0&apos; / account&apos; / change / address_index</span><br></pre></td></tr></table></figure>
<p>此外，除了使用<code>account</code>来标识账户外，还使用了该账户公钥的哈希值对账户进行唯一表示，表示方法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wallet = crypto.createHash(<span class="string">"sha256"</span>).update(xPubKey, <span class="string">"utf8"</span>).digest(<span class="string">"base64"</span>);</span><br></pre></td></tr></table></figure>
<p>ByteBall中还有一类特殊的地址，即设备地址，其采用的路径结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m / 1&apos; / *</span><br></pre></td></tr></table></figure>
<p>ByteBall钱包使用了<code>bitcore-lib</code>和<code>bitcore-mnemonic</code>两个库进行钱包管理，简单的使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mnemonic = <span class="built_in">require</span>(<span class="string">'bitcore-mnemonic'</span>);</span><br><span class="line"><span class="keyword">var</span> Bitcore = <span class="built_in">require</span>(<span class="string">'bitcore-lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成助记词</span></span><br><span class="line"><span class="comment">// 'fee decorate step culture autumn game social very lemon drum embrace much'</span></span><br><span class="line"><span class="keyword">var</span> mnemonic = <span class="keyword">new</span> Mnemonic();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成HD钱包私钥</span></span><br><span class="line"><span class="comment">// &lt;HDPrivateKey: xprv9s21ZrQH143K2P4n8N1MYXW4NPfPuH7K3z4uYe6iRxHHXMEUJQRriizTdMuN6rh5XLH4okZm69c7THSN7M5Lk8WSFXDd6b9DBcb6nAdxw7n&gt;</span></span><br><span class="line"><span class="keyword">var</span> xPrivKey = mnemonic.toHDPrivateKey();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成HD钱包公钥，account=0</span></span><br><span class="line"><span class="comment">// &lt;HDPublicKey: xpub6BqpEDyiVUcuzwzhn3jznUooytK5k9weeZqoM9vRpKbaHJGdyXZ3uk6HzpwYfCbxUuTsn41RgTpsTqA44uC4Ce2vRAZAcr9n5EyRtZxczbs&gt;</span></span><br><span class="line"><span class="keyword">var</span> xPubKey = Bitcore.HDPublicKey(xPrivKey.derive(<span class="string">"m/44'/0'/0'"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成设备私钥，用于产生设备地址</span></span><br><span class="line"><span class="comment">// &lt;HDPrivateKey: xprv9u8BXQraRhyRypxQj4ffhEohzDyjLbqezoCuFCHpLHazDbi9ymLb1zp6aKmDpTpyxXw8Uc6HbCRSZMEtW71Eie1QPi2T3RweoKWrdymxGEf&gt;</span></span><br><span class="line"><span class="keyword">var</span> devicePrivKey = xPrivKey.derive(<span class="string">"m/1'"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h2><p>ByteBall中包括三类地址：</p>
<ul>
<li>普通地址</li>
<li>共享地址</li>
<li>设备地址</li>
</ul>
<p>其中，普通地址和共享地址都是通过地址定义脚本生成的，二者的区别类似于Bitcoin中的P2PKH地址和P2SH地址，具体细节可参考<a href="https://bbfans.org/2018/05/21/byteball%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E5%9C%B0%E5%9D%80%E3%80%81%E8%84%9A%E6%9C%AC%E5%8F%8A%E5%90%88%E7%BA%A6/" target="_blank" rel="noopener">《ByteBall原理解析（三）地址、脚本及合约》</a>；设备地址是采用设备公钥生成的，地址格式和校验规则与普通地址相同，只是前缀添加了<code>0</code>。</p>
<p>给定需要生成地址的对象，ByteBall生成地址时采用的是<code>ripemd160</code>哈希，并给地址加上校验，使用的是<code>byteballcore/object_hash.js</code>中的函数<code>getChash160()</code>函数。</p>
<p>具体来说，设备地址生成方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ecdsa = <span class="built_in">require</span>(<span class="string">'secp256k1'</span>);  <span class="comment">// 椭圆曲线非对称加密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取设备公钥</span></span><br><span class="line"><span class="keyword">var</span> pubkey = ecdsa.publicKeyCreate(devicePrivKey.privateKey.bn.toBuffer(&#123;<span class="attr">size</span>:<span class="number">32</span>&#125;), <span class="literal">true</span>).toString(<span class="string">'base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成设备地址</span></span><br><span class="line"><span class="keyword">var</span> objectHash = <span class="built_in">require</span>(<span class="string">'byteballcore/object_hash.js'</span>);</span><br><span class="line"><span class="keyword">var</span> device_address = <span class="string">'0'</span> + objectHash.getChash160(pubkey);</span><br></pre></td></tr></table></figure>
<p>普通地址生成方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change=0 address_index=0，生成公钥</span></span><br><span class="line"><span class="keyword">var</span> pubkey = xPubKey.derive(<span class="string">'m/0/0'</span>).publicKey.toBuffer().toString(<span class="string">'base64'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定地址定义脚本，为单签名</span></span><br><span class="line"><span class="keyword">var</span> arrDefinition = [<span class="string">"sig"</span>, &#123;<span class="string">"pubkey"</span>: pubkey&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成地址</span></span><br><span class="line"><span class="keyword">var</span> address = objectHash.getChash160(arrDefinition);</span><br></pre></td></tr></table></figure>
<p>共享地址的生成方法与普通地址基本一致，唯一的差别在于地址定义脚本要更加复杂一些，具体细节可参考前面给出的那篇文章。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/byteball-network-protocol/" itemprop="url">
                  ByteBall网络节点通信协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-06-14T22:39:55+08:00" content="2018-06-14">
              2018-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/06/14/byteball-network-protocol/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/14/byteball-network-protocol/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/06/14/byteball-network-protocol/" class="leancloud_visitors" data-flag-title="ByteBall网络节点通信协议详解">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ByteBall网络节点通信协议详解"><a href="#ByteBall网络节点通信协议详解" class="headerlink" title="ByteBall网络节点通信协议详解"></a>ByteBall网络节点通信协议详解</h2><p>P2P网络是区块链网络的基础，网络中各个节点通过相互交换消息实现各种功能，包括收发交易、数据同步等操作。本文将对ByteBall网络节点的通信接口进行详细分析。</p>
<p>ByteBall网络节点之间采用websocket连接，采用json格式消息进行通信，消息可表示为<code>{type: type, content: content}</code>。ByteBall中的消息类型主要包括三类，即消息的type包括三种<code>request</code>、<code>response</code>以及<code>justsaying</code>，当然也可以自定义其它类型的消息。下面对消息的具体格式和处理流程进行解析。</p>
<h3 id="request：请求消息"><a href="#request：请求消息" class="headerlink" title="request：请求消息"></a>request：请求消息</h3><p>请求消息的格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: command,</span><br><span class="line">        params: params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>tag</code>为request消息的BASE64哈希值。</p>
<p>发送请求消息的函数原型为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span>(<span class="params">ws, command, params, bReroutable, responseHandler</span>)</span></span><br><span class="line"><span class="function">// <span class="title">ws</span>: 发送请求的<span class="title">websocket</span>连接</span></span><br><span class="line"><span class="function">// <span class="title">command</span>: 请求命令</span></span><br><span class="line"><span class="function">// <span class="title">params</span>: 请求参数</span></span><br><span class="line"><span class="function">// <span class="title">bReroutable</span>: 是否重新路由</span></span><br><span class="line"><span class="function">// <span class="title">responseHandler</span>: 请求响应处理回调函数</span></span><br></pre></td></tr></table></figure>
<p>通过<code>sendRequest()</code>发出的每个请求会生成一个<code>tag</code>作为该请求的标识，并在内存中保留该请求的相关处理信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ws.assocPendingRequests[tag] = &#123;</span><br><span class="line">    request: request,</span><br><span class="line">    responseHandlers: [responseHandler],</span><br><span class="line">    reroute: reroute,</span><br><span class="line">    reroute_timer: reroute_timer,</span><br><span class="line">    cancel_timer: cancel_timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当请求发出后，若对方没有回应时有两种选择，一种是采用<code>reroute</code>，另一种是<code>cancel</code>。<code>reroute</code>的<code>timeout</code>为5s，<code>cancel</code>的<code>timeout</code>时间为300秒。</p>
<p>当接收到响应后（位于函数<code>handleResponse()</code>），在调用相应回调函数<code>responseHandlers</code>后，请求信息<code>ws.assocPendingRequests[tag]</code>被删除。</p>
<p>如果相关的连接被关闭，则清理该连接上的所有请求信息（位于函数<code>cancelRequestOnClosedConnection()</code>）。</p>
<h3 id="response：响应消息"><a href="#response：响应消息" class="headerlink" title="response：响应消息"></a>response：响应消息</h3><p>响应消息的格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'response',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        response: response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>tag</code>对应于请求消息中的<code>tag</code>。</p>
<p>发送响应消息的函数原型为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendResponse</span>(<span class="params">ws, tag, response</span>)</span></span><br><span class="line"><span class="function">// <span class="title">ws</span>: 发送响应的<span class="title">websocket</span>连接</span></span><br><span class="line"><span class="function">// <span class="title">tag</span>: 发送响应对应的<span class="title">tag</span></span></span><br><span class="line"><span class="function">// <span class="title">response</span>: 响应消息内容</span></span><br></pre></td></tr></table></figure>
<p>当收到对端节点请求后，设置<code>ws.assocInPreparingResponse[tag]=true</code>，并在回复响应后删除。</p>
<h3 id="justsaying：其它消息"><a href="#justsaying：其它消息" class="headerlink" title="justsaying：其它消息"></a>justsaying：其它消息</h3><p>其它消息包括的内容比较多，比如版本、心跳、hub登录等，其格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'justsaying',</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: subject,</span><br><span class="line">        body: body</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送其它消息的函数原型为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendJustsaying</span>(<span class="params">ws, subject, body</span>)</span></span><br><span class="line"><span class="function">// <span class="title">ws</span>: 发送消息的<span class="title">websocket</span>连接</span></span><br><span class="line"><span class="function">// <span class="title">subject</span>: 消息主题</span></span><br><span class="line"><span class="function">// <span class="title">body</span>: 消息内容</span></span><br></pre></td></tr></table></figure>
<h3 id="常见通信接口"><a href="#常见通信接口" class="headerlink" title="常见通信接口"></a>常见通信接口</h3><h4 id="获取见证人列表（get-witnesses）"><a href="#获取见证人列表（get-witnesses）" class="headerlink" title="获取见证人列表（get_witnesses）"></a>获取见证人列表（get_witnesses）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'get_witnesses'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到请求后，从数据库中读取当前的见证人列表并返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myWitnesses.readMyWitnesses(<span class="function"><span class="keyword">function</span>(<span class="params">arrWitnesses</span>)</span>&#123;</span><br><span class="line">    sendResponse(ws, tag, arrWitnesses);</span><br><span class="line">&#125;, <span class="string">'wait'</span>);</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'BVVJ2K7ENPZZ3VYZFWQWK7ISPCATFIW3'</span>,</span><br><span class="line">  <span class="string">'DJMMI5JYA5BWQYSXDPRZJVLW3UGL3GJS'</span>,</span><br><span class="line">  <span class="string">'FOPUBEUPBC6YLIQDLKL6EW775BMV7YOH'</span>,</span><br><span class="line">  <span class="string">'GFK3RDAPQLLNCMQEVGGD2KCPZTLSG3HN'</span>,</span><br><span class="line">  <span class="string">'H5EZTQE7ABFH27AUDTQFMZIALANK6RBG'</span>,</span><br><span class="line">  <span class="string">'I2ADHGP4HL6J37NQAD73J7E5SKFIXJOT'</span>,</span><br><span class="line">  <span class="string">'JEDZYC2HMGDBIDQKG3XSTXUSHMCBK725'</span>,</span><br><span class="line">  <span class="string">'JPQKPRI5FMTQRJF4ZZMYZYDQVRD55OTC'</span>,</span><br><span class="line">  <span class="string">'OYW2XTDKSNKGSEZ27LMGNOPJSYIXHBHC'</span>,</span><br><span class="line">  <span class="string">'S7N5FE42F6ONPNDQLCF64E2MGFYKQR2I'</span>,</span><br><span class="line">  <span class="string">'TKT4UESIKTTRALRRLWS4SENSTJX6ODCW'</span>,</span><br><span class="line">  <span class="string">'UENJPVZ7HVHM6QGVGT6MWOJGGRTUTJXQ'</span> ]</span><br></pre></td></tr></table></figure>
<p><code>network.js</code>中在函数<code>initWitenessesIfNecessary()</code>中使用。</p>
<h4 id="获取节点列表（get-peers）"><a href="#获取节点列表（get-peers）" class="headerlink" title="获取节点列表（get_peers）"></a>获取节点列表（get_peers）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'get_peers'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回对端节点已连接的节点列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendResponse(ws, tag, arrPeerUrls)</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'wss://byteball.fr/bb'</span>,</span><br><span class="line">  <span class="string">'wss://byteball-hub.com/bb'</span>,</span><br><span class="line">  <span class="string">'wss://hub.byteball.ee'</span> ]</span><br></pre></td></tr></table></figure>
<p><code>network.js</code>中可以使用<code>requestPeers()</code>函数发出请求。</p>
<h4 id="获取交易数据（get-joint）"><a href="#获取交易数据（get-joint）" class="headerlink" title="获取交易数据（get_joint）"></a>获取交易数据（get_joint）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'get_joint',</span><br><span class="line">        params: unit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若找到，则返回响应交易数据；否则，返回交易未找到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">storage.readJoint(db, unit, &#123;</span><br><span class="line">    ifFound: <span class="function"><span class="keyword">function</span>(<span class="params">objJoint</span>)</span>&#123;</span><br><span class="line">        sendJoint(ws, objJoint, tag);</span><br><span class="line">    &#125;,</span><br><span class="line">    ifNotFound: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        sendResponse(ws, tag, &#123;<span class="attr">joint_not_found</span>: unit&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">joint</span>:</span><br><span class="line">   &#123; <span class="attr">unit</span>:</span><br><span class="line">      &#123; <span class="attr">unit</span>: <span class="string">'OcrOftkwCwTYAaGq0zV8FecAK/CKED++Ddewh2c2M60='</span>,</span><br><span class="line">        version: <span class="string">'1.0'</span>,</span><br><span class="line">        alt: <span class="string">'1'</span>,</span><br><span class="line">        witness_list_unit: <span class="string">'oj8yEksX9Ubq7lLc+p6F2uyHUuynugeVq4+ikT67X6E='</span>,</span><br><span class="line">        last_ball_unit: <span class="string">'p7obFdGHM5pTWPytNeRIjmamBe7485aDTzuddWI9yWY='</span>,</span><br><span class="line">        last_ball: <span class="string">'wmiP2BvT7FFFtwy5qB+UsA4j8I5KbmBVA6mFCgwQUas='</span>,</span><br><span class="line">        headers_commission: <span class="number">344</span>,</span><br><span class="line">        payload_commission: <span class="number">157</span>,</span><br><span class="line">        main_chain_index: <span class="number">2791799</span>,</span><br><span class="line">        timestamp: <span class="number">1528796161</span>,</span><br><span class="line">        parent_units: [<span class="built_in">Array</span>],</span><br><span class="line">        authors: [<span class="built_in">Array</span>],</span><br><span class="line">        messages: [<span class="built_in">Array</span>] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p><code>network.js</code>中可以使用<code>requestJoints()</code>函数发出请求。</p>
<h4 id="发送交易数据（post-joint）"><a href="#发送交易数据（post-joint）" class="headerlink" title="发送交易数据（post_joint）"></a>发送交易数据（post_joint）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'post_joint',</span><br><span class="line">        params: joint</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收到请求后，对<code>joint</code>数据进行检查，若通过，则返回<code>accepted</code>；否则，返回相应错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handlePostedJoint(ws, objJoint, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    error ? sendErrorResponse(ws, tag, error) : sendResponse(ws, tag, <span class="string">'accepted'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用方法可参考<code>network.js</code>中的<code>postJointToLightVendor()</code>函数。</p>
<h4 id="发送心跳数据（heartbeat）"><a href="#发送心跳数据（heartbeat）" class="headerlink" title="发送心跳数据（heartbeat）"></a>发送心跳数据（heartbeat）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'heartbeat'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法可参考<code>network.js</code>中的<code>heartbeat()</code>函数。</p>
<p>ByteBall网络中节点之间依靠心跳请求维持连接，当超过<code>HEARTBEAT_RESPONSE_TIMEOUT=60s</code>没有收到对端节点的消息时，将会关闭与该节点的连接。ByteBall中默认3-4s向对端节点发送心跳请求。</p>
<h4 id="订阅交易数据（subscribe）"><a href="#订阅交易数据（subscribe）" class="headerlink" title="订阅交易数据（subscribe）"></a>订阅交易数据（subscribe）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'subscribe',</span><br><span class="line">        params: &#123;</span><br><span class="line">            subscription_id: subscription_id, // 订阅编号</span><br><span class="line">            last_mci: last_mci                // 订阅起始mci</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收到请求后，若<code>last_mci&gt;0</code>，则返回从该mci起始的joints；否则，返回当前网络中的叶子交易。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ValidationUtils.isNonnegativeInteger(params.last_mci))</span><br><span class="line">    sendJointsSinceMci(ws, params.last_mci);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sendFreeJoints(ws);</span><br></pre></td></tr></table></figure>
<p>订阅后，当收到新交易时，会向已订阅的节点进行转发（<code>forwardJoint(ws, objJoint)</code>）。使用方法可参考<code>network.js</code>中的<code>subscribe()</code>函数。</p>
<h4 id="同步交易数据（catchup）"><a href="#同步交易数据（catchup）" class="headerlink" title="同步交易数据（catchup）"></a>同步交易数据（catchup）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'catchup',</span><br><span class="line">        params: &#123;</span><br><span class="line">            witnesses: witnesses,                 // 见证人列表</span><br><span class="line">            last_stable_mci: last_stable_mci,     // 稳定mci</span><br><span class="line">            last_known_mci: last_known_mci        // 已知mci</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须在订阅状态下使用，接收到请求后，返回主链序号从<code>last_known_mci</code>至<code>last_stable_mci</code>之间的交易数据及其相关信息<code>objCatchupChain</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">catchup.prepareCatchupChain(catchupRequest, &#123;</span><br><span class="line">    ifError: <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        sendErrorResponse(ws, tag, error);</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;,</span><br><span class="line">    ifOk: <span class="function"><span class="keyword">function</span>(<span class="params">objCatchupChain</span>)</span>&#123;</span><br><span class="line">        sendResponse(ws, tag, objCatchupChain);</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>objCatchupChain</code>包括以下几部分信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objCatchupChain = &#123;</span><br><span class="line">    unstable_mc_joints: [], <span class="comment">// 候选主链上未稳定的单元列表</span></span><br><span class="line">    stable_last_ball_joints: [], <span class="comment">// 已稳定的单元列表</span></span><br><span class="line">    witness_change_and_definition_joints: [] <span class="comment">// 见证人或地址定义发生变化的单元列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用方法可参考<code>network.js</code>中的<code>requestCatchup()</code>函数。</p>
<h4 id="获取哈希树（get-hash-tree）"><a href="#获取哈希树（get-hash-tree）" class="headerlink" title="获取哈希树（get_hash_tree）"></a>获取哈希树（get_hash_tree）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'get_hash_tree',</span><br><span class="line">        params: &#123;</span><br><span class="line">            from_ball: from_ball,</span><br><span class="line">            to_ball: to_bal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须在订阅状态下使用，接收到请求后，返回从<code>from_ball</code>至<code>to_ball</code>主链序号之间的所有ball交易数据。使用方法可参考<code>network.js</code>中的<code>requestNextHashTree()</code>函数。</p>
<h4 id="获取主链序号（get-last-mci）"><a href="#获取主链序号（get-last-mci）" class="headerlink" title="获取主链序号（get_last_mci）"></a>获取主链序号（get_last_mci）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'get_last_mci'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回目前最大的主链序号。</p>
<h4 id="通过Hub向设备发送消息（hub-deliver）"><a href="#通过Hub向设备发送消息（hub-deliver）" class="headerlink" title="通过Hub向设备发送消息（hub/deliver）"></a>通过Hub向设备发送消息（hub/deliver）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/deliver',</span><br><span class="line">        params: &#123;</span><br><span class="line">            to: device_address,</span><br><span class="line">            pubkey: pubkey,</span><br><span class="line">            signature: signature,</span><br><span class="line">            encrypted_package: encrypted_message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Hub向其它设备发送加密消息，使用方法可以参考<code>device.js</code>中的<code>sendPreparedMessageToConnectedHub()</code>函数。</p>
<h4 id="从Hub获取配对设备临时公钥（hub-get-temp-pubkey）"><a href="#从Hub获取配对设备临时公钥（hub-get-temp-pubkey）" class="headerlink" title="从Hub获取配对设备临时公钥（hub/get_temp_pubkey）"></a>从Hub获取配对设备临时公钥（hub/get_temp_pubkey）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_temp_pubkey',</span><br><span class="line">        params: permanent_pubkey</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过永久公钥<code>permanent_pubkey</code>从Hub处获取对端设备的临时公钥。</p>
<h4 id="设备向Hub更新临时公钥（hub-temp-pubkey）"><a href="#设备向Hub更新临时公钥（hub-temp-pubkey）" class="headerlink" title="设备向Hub更新临时公钥（hub/temp_pubkey）"></a>设备向Hub更新临时公钥（hub/temp_pubkey）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/temp_pubkey',</span><br><span class="line">        params: &#123;</span><br><span class="line">            temp_pubkey: temp_pubkey,</span><br><span class="line">            pubkey: permanent_pubkey,</span><br><span class="line">            signature: signature</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向Hub更新本设备的临时公钥，设备必须登陆到Hub上。接收到请求后，对参数及签名进行验证，如果成功则返回响应消息<code>updated</code>。</p>
<h4 id="开启通知（hub-enable-notification）"><a href="#开启通知（hub-enable-notification）" class="headerlink" title="开启通知（hub/enable_notification）"></a>开启通知（hub/enable_notification）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/enable_notification',</span><br><span class="line">        params: registrationId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备开启推送通知，目前还未使用。</p>
<h4 id="关闭通知（hub-disable-notification）"><a href="#关闭通知（hub-disable-notification）" class="headerlink" title="关闭通知（hub/disable_notification）"></a>关闭通知（hub/disable_notification）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/disable_notification',</span><br><span class="line">        params: registrationId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备关闭推送通知，目前还未使用。</p>
<h4 id="获取机器人列表（hub-get-bots）"><a href="#获取机器人列表（hub-get-bots）" class="headerlink" title="获取机器人列表（hub/get_bots）"></a>获取机器人列表（hub/get_bots）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_bots'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回Hub节点上的机器人列表，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...</span><br><span class="line"> &#123; id: 27,</span><br><span class="line">    name: 'Worldopoly ICO',</span><br><span class="line">    pairing_code: 'AwyoKVsyxajATgLXa9Jhh8NBRTnUaZNHdi85c43g+GoJ@byteball.org/bb#0000',</span><br><span class="line">    description: 'Worldopoly is the world’s first mobile game combining AR, AI, Geolocationing, Blockchain, and DAG. The ICO is active until 17 May 2018, and you can buy WPT tokens with Bytes, BTC, or Ether.  WPT token is issued both on Byteball and Ethereum platforms but investors on Byteball platform receive increased bonus (even if they pay in ETH or BTC) for investments up to 30 ETH.\n\nWebsite: https://worldopoly.io' &#125;,</span><br><span class="line">  &#123; id: 28,</span><br><span class="line">    name: 'WhiteLittle Airdrop 小白币糖果机器人',</span><br><span class="line">    pairing_code: 'Ahe4jkq5GvgLQ2h5ftqRMjWBBumUEN96tWoSfEQ9TGHF@byteball.org/bb#0000',</span><br><span class="line">    description: '小白链机器人送出小白币糖果。小白链是专门为想进入区块链行业的小白们量身打造的帮助平台，其目的是建立一个基于字节雪球技术为小白们提供有效帮助的信息发现生态平台。小白链的设计初衷是构建一套合理的激励机制，能够及时得到帮助，又让提供帮助的区块链从业者得到合理的回报。\n\n开发者：123cb.net' &#125;,</span><br><span class="line">  &#123; id: 32,</span><br><span class="line">    name: 'Exchange bot for dual-chain tokens',</span><br><span class="line">    pairing_code: 'A+dAU2j/Tm9lnlmc2SryltsfVzOq9GLPxccAq+dClCxr@byteball.org/bb#f7b42a61a3ba6a34cbeeb18d37979927ad1103fc',</span><br><span class="line">    description: 'For tokens issued both on Byteball and Ethereum platforms, the bot enables seamless exchange between Byteball and Ethereum tokens.\n\nDeveloper: HDRProtocol, https://github.com/HDRProtocol/exchanger' &#125;,</span><br><span class="line"> ...]</span><br></pre></td></tr></table></figure>
<h4 id="获取资产元数据（hub-get-asset-metadata）"><a href="#获取资产元数据（hub-get-asset-metadata）" class="headerlink" title="获取资产元数据（hub/get_asset_metadata）"></a>获取资产元数据（hub/get_asset_metadata）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_asset_metadata',</span><br><span class="line">        params: asset</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Hub节点上获取已发布资产的信息，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; metadata_unit: 'Rg3DNkDJJ2DWfIzTj3Ypz8CBGi617wl07QkJq7Z5soc=',</span><br><span class="line">  registry_address: 'AM6GTUKENBYA54FYDAKX2VLENFZIMXWG',</span><br><span class="line">  suffix: null &#125;</span><br></pre></td></tr></table></figure>
<p>具体使用方法可以参考<code>wallet.js</code>中的<code>fetchAssetMetadata()</code>函数。</p>
<h4 id="从Hub获取交易历史（light-get-history）"><a href="#从Hub获取交易历史（light-get-history）" class="headerlink" title="从Hub获取交易历史（light/get_history）"></a>从Hub获取交易历史（light/get_history）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_asset_metadata',</span><br><span class="line">        params: &#123;</span><br><span class="line">            witnesses: witnesses,</span><br><span class="line">            requested_joints: joints,</span><br><span class="line">            addresses: addresses</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求特定交易或地址的历史数据，仅适用于轻节点，具体使用方法可以参考<code>network.js</code>中的<code>requestHistoryFor()</code>函数。轻钱包可以根据获取的历史数据构建证据链，从而验证交易的可靠性。</p>
<p>对于轻钱包而言，它本身不保存所有的交易数据，而需要采用<code>requestFromLightVendor()</code>从<code>Vendor</code>处获取数据，目前<code>Vendor</code>为<code>Hub</code>节点。</p>
<h4 id="获取连接证明（light-get-link-proofs）"><a href="#获取连接证明（light-get-link-proofs）" class="headerlink" title="获取连接证明（light/get_link_proofs）"></a>获取连接证明（light/get_link_proofs）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_link_proofs',</span><br><span class="line">        params: units</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取特定交易的连接证明，仅适用于轻节点，具体使用方法可以参考<code>network.js</code>中的<code>checkThatEachChainElementIncludesThePrevious()</code>。</p>
<h4 id="获取父单元及见证单元（light-get-parents-and-last-ball-and-witness-list-unit）"><a href="#获取父单元及见证单元（light-get-parents-and-last-ball-and-witness-list-unit）" class="headerlink" title="获取父单元及见证单元（light/get_parents_and_last_ball_and_witness_list_unit）"></a>获取父单元及见证单元（light/get_parents_and_last_ball_and_witness_list_unit）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_parents_and_last_ball_and_witness_list_unit',</span><br><span class="line">        params: &#123;</span><br><span class="line">            witnesses: witnesses</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轻节点获取这些信息后，可用于构造自己的交易数据。返回的响应数据，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; parent_units: [ 'ovIwMvA9MMKgxiHrslJQhQGzUAIXlRs47grVdG/er3s=' ],</span><br><span class="line">  last_stable_mc_ball: 'osJhTYZv+HS5hGhH01A/3PKpyaxPRbtcxQEaUj/a/h4=',</span><br><span class="line">  last_stable_mc_ball_unit: '+9fxcmxM90mhIxvtJ3yo++tAoYofyoDmPqBQEwbEHDA=',</span><br><span class="line">  last_stable_mc_ball_mci: 2805208,</span><br><span class="line">  witness_list_unit: 'oj8yEksX9Ubq7lLc+p6F2uyHUuynugeVq4+ikT67X6E=' &#125;</span><br></pre></td></tr></table></figure>
<p>具体使用方法可以参考<code>composer.js</code>中的<code>composeJoint()</code>函数。</p>
<h4 id="查询用户认证信息（light-get-attestation）"><a href="#查询用户认证信息（light-get-attestation）" class="headerlink" title="查询用户认证信息（light/get_attestation）"></a>查询用户认证信息（light/get_attestation）</h4><p>请求消息为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: 'request',</span><br><span class="line">    content: &#123;</span><br><span class="line">        tag: tag,</span><br><span class="line">        command: 'hub/get_attestation',</span><br><span class="line">        params: &#123;</span><br><span class="line">        	attestor_address: attestor_address,</span><br><span class="line">        	field: field,</span><br><span class="line">        	value: value</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收到请求后，如果Hub查询到相应的认证信息，返回认证信息所在的交易单元。</p>
<h4 id="发送版本信息（version）"><a href="#发送版本信息（version）" class="headerlink" title="发送版本信息（version）"></a>发送版本信息（version）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'version'</span>,</span><br><span class="line">        body: &#123;</span><br><span class="line">            protocol_version: protocol_version,</span><br><span class="line">            alt: alt,</span><br><span class="line">            library: name,</span><br><span class="line">            library_version: version,</span><br><span class="line">            program: program,</span><br><span class="line">            program_version: program_version</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体用法可以参考<code>network.js</code>中的<code>sendVersion()</code>函数。</p>
<h4 id="已发送完所有交易（free-joints-end）"><a href="#已发送完所有交易（free-joints-end）" class="headerlink" title="已发送完所有交易（free_joints_end）"></a>已发送完所有交易（free_joints_end）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'free_joints_end'</span>,</span><br><span class="line">        body: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于通知对方所有的叶子交易已发送完毕，具体用法可参考<code>network.js</code>中的<code>sendFreeJoints()</code>及<code>sendJointsSinceMci()</code></p>
<h4 id="发送隐私交易（private-payment）"><a href="#发送隐私交易（private-payment）" class="headerlink" title="发送隐私交易（private_payment）"></a>发送隐私交易（private_payment）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'private_payment'</span>,</span><br><span class="line">        body: privateElement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来向对方发送隐私交易的证据链，但该条<code>justsaying</code>消息并没有使用。实际上隐私资产是在两个设备之间通过加密消息进行点对点发送的，相关代码位于<code>wallet_general.js</code>的<code>sendPrivatePayments()</code>中，发送加密消息采用的是<code>device.js</code>中的<code>sendMessageToDevice()</code>（底层使用的是<code>hub/deliver</code>接口）。</p>
<h4 id="登录Hub（hub-login）"><a href="#登录Hub（hub-login）" class="headerlink" title="登录Hub（hub/login）"></a>登录Hub（hub/login）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'hub/login'</span>,</span><br><span class="line">        body: &#123;</span><br><span class="line">            challenge: challenge,</span><br><span class="line">            pubkey: pubkey,</span><br><span class="line">			signature: signature</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该消息用于设备登录Hub。</p>
<h4 id="获取设备新消息（hub-refresh）"><a href="#获取设备新消息（hub-refresh）" class="headerlink" title="获取设备新消息（hub/refresh）"></a>获取设备新消息（hub/refresh）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'hub/refresh'</span>,</span><br><span class="line">        body: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于从Hub上获取该设备还未接收的消息。</p>
<h4 id="发送配对消息（hub-challenge）"><a href="#发送配对消息（hub-challenge）" class="headerlink" title="发送配对消息（hub/challenge）"></a>发送配对消息（hub/challenge）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'hub/challenge'</span>,</span><br><span class="line">        body: challenge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Hub发送给设备，用于设备登录。</p>
<h4 id="发送设备消息（hub-message）"><a href="#发送设备消息（hub-message）" class="headerlink" title="发送设备消息（hub/message）"></a>发送设备消息（hub/message）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'hub/message'</span>,</span><br><span class="line">        body: &#123;</span><br><span class="line">            message_hash: message_hash,</span><br><span class="line">            message: message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Hub转发给设备的消息，可配合<code>hub/deliver</code>使用，具体用法可参考<code>sendStoredDeviceMessages()</code>。</p>
<h4 id="轻钱包交易更新消息（light-have-updates）"><a href="#轻钱包交易更新消息（light-have-updates）" class="headerlink" title="轻钱包交易更新消息（light/have_updates）"></a>轻钱包交易更新消息（light/have_updates）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'light/have_updates'</span>,</span><br><span class="line">        body: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当轻钱包使用<code>light/get_history</code>从Hub上请求交易历史时，Hub会在<code>watched_light_addresses</code>中记录下请求的地址列表或者<code>watched_light_units</code>中记录下请求的交易列表。当相关的交易达到稳定时，Hub将通过<code>light/have_updates</code>消息通知轻钱包。然后，轻钱包可以通过<code>light/get_history</code>确定已达到稳定的交易单元。</p>
<h4 id="添加轻钱包监视地址（light-new-address-to-watch）"><a href="#添加轻钱包监视地址（light-new-address-to-watch）" class="headerlink" title="添加轻钱包监视地址（light/new_address_to_watch）"></a>添加轻钱包监视地址（light/new_address_to_watch）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'light/new_address_to_watch'</span>,</span><br><span class="line">        body: address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轻钱包向Hub请求将地址加入<code>watch_light_addresses</code>表中，从而可以从Hub接收相应地址的交易信息，具体用法可参考<code>network.js</code>中的<code>addLightWatchedAddress()</code>函数。</p>
<h4 id="交易价格消息（exchange-rates）"><a href="#交易价格消息（exchange-rates）" class="headerlink" title="交易价格消息（exchange_rates）"></a>交易价格消息（exchange_rates）</h4><p>消息格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'justsaying'</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">        subject: <span class="string">'exchange_rates'</span>,</span><br><span class="line">        body: exchangeRates</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Hub广播的交易价格消息，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 'justsaying',</span><br><span class="line">  &#123; subject: 'exchange_rates',</span><br><span class="line">    body: &#123; GBYTE_USD: 119.1914071839, GBB_USD: 3.6949336227009 &#125; &#125; ]</span><br></pre></td></tr></table></figure>
<h3 id="通信接口列表"><a href="#通信接口列表" class="headerlink" title="通信接口列表"></a>通信接口列表</h3><table>
<thead>
<tr>
<th>type</th>
<th>content</th>
<th>function</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>{tag: tag, command: command, params: params}</td>
<td>sendRequest()</td>
<td>通用发送请求</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘get_peers’}</td>
<td>requestPeers()</td>
<td>请求节点列表</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘get_witnesses’}</td>
<td>initWitenessesIfNecessary()</td>
<td>请求见证人列表</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘get_joint’, params: unit}</td>
<td>requestJoints()</td>
<td>请求交易信息</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘post_joint’, params: joint}</td>
<td>postJointToLightVendor()</td>
<td>发送交易信息</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘heartbeat’}</td>
<td>heartbeat()</td>
<td>心跳请求</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘subscribe’, params: {subscription_id, last_mci}}</td>
<td>subscribe()</td>
<td>订阅交易</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘catchup’, params: {witnesses, last_stable_mci, last_known_mci}}</td>
<td>requestCatchup()</td>
<td>同步数据</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘get_hash_tree’, params: {from_ball,to_ball}}</td>
<td>requestNextHashTree()</td>
<td>请求哈希树</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘get_last_mci’}</td>
<td></td>
<td>获取主链序号</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/deliver’, params: {encrypted_package, to, pubkey, signature}}</td>
<td></td>
<td>通过Hub向设备发送消息</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/get_temp_pubkey’, params: pubkey}</td>
<td></td>
<td>从Hub获取配对设备临时公钥</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/temp_pubkey’, params: {temp_pubkey, pubkey, signature}}</td>
<td></td>
<td>设备向Hub更新临时公钥</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/enable_notification’}</td>
<td></td>
<td>开启通知</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/disable_notification’}</td>
<td></td>
<td>关闭通知</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/get_bots’}</td>
<td></td>
<td>获取机器人列表</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘hub/get_asset_metadata’, params: asset}</td>
<td>fetchAssetMetadata()</td>
<td>获取资产元数据</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘light/get_history’, params: {witnesses, requested_joints, addresses}}</td>
<td>requestHistoryFor()</td>
<td>从Hub获取交易历史</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘light/get_link_proofs’, params: units</td>
<td></td>
<td>获取连接证明</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘light/get_parents_and_last_ball_and_witness_list_unit’, params: {witnesses}}</td>
<td>composeJoint()</td>
<td>获取父单元及见证单元</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, command: ‘light/get_attestation’, params: { attestor_address, field, value}}</td>
<td></td>
<td>查询用户认证信息</td>
</tr>
<tr>
<td>response</td>
<td>{tag: tag, response: response}</td>
<td>sendResponse()</td>
<td>通用发送响应</td>
</tr>
<tr>
<td></td>
<td>{tag: tag, response: {error: error}}</td>
<td>sendErrorResponse()</td>
<td>发送响应错误</td>
</tr>
<tr>
<td>justsaying</td>
<td>{subject: subject, body: body}</td>
<td>sendJustsaying()</td>
<td>发送其它消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘error’, body: error}</td>
<td>sendError()</td>
<td>发送错误消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘info’, body: content}</td>
<td>sendInfo()</td>
<td>发送通知消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘result’, body: content}</td>
<td>sendResult()</td>
<td>发送结果消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘result’, body: {unit, result: ‘error’, error}}</td>
<td>sendErrorResult()</td>
<td>发送错误结果</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘version’, body: {protocol_version, alt, library, library_version, program, program_version}}</td>
<td>sendVersion()</td>
<td>发送版本信息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘new_version’, body: {version}}</td>
<td></td>
<td>发现新版本</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘ hub/push_project_number’, body: { projectNumber}}</td>
<td></td>
<td>推送API编号</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘bugreport’, body: {message, exception}}</td>
<td></td>
<td>报告bug</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘free_joints_end’, body: null}</td>
<td>sendFreeJoints()</td>
<td>已发送完所有交易</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘private_payment’, body: privateElements}</td>
<td></td>
<td>发送隐私交易</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘my_url’, body: url}</td>
<td></td>
<td>发送连接地址</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘want_echo’, body: echo_string}</td>
<td></td>
<td>请求对方回应</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘your_echo’, body: echo_string}</td>
<td></td>
<td>发送回应信息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/login’, body: {challenge, pubkey, signature}}</td>
<td></td>
<td>登录Hub</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/refresh’, body: null}</td>
<td></td>
<td>获取设备新消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/delete’, body: message_hash}</td>
<td></td>
<td>删除设备消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/challenge’, body: challenge}</td>
<td></td>
<td>发送配对消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/message’, body: {message_hash, message}}</td>
<td>sendStoredDeviceMessages()</td>
<td>发送设备消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘hub/message_box_status’, body: ‘has_more’/‘empty’}</td>
<td>sendStoredDeviceMessages()</td>
<td>设备消息状态</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘light/have_updates’, body: null}</td>
<td></td>
<td>轻钱包交易更新消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘light/new_address_to_watch’, body: address}</td>
<td>addLightWatchedAddress()</td>
<td>添加轻钱包监视地址</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘exchange_rates’, body: exchangeRates}</td>
<td></td>
<td>交易价格消息</td>
</tr>
<tr>
<td></td>
<td>{subject: ‘upgrade_required’, body: null}</td>
<td></td>
<td>强制升级消息</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/13/byteball-flaws/" itemprop="url">
                  Byteball目前存在的一些问题及改进方向
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-13T22:09:55+08:00" content="2018-05-13">
              2018-05-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/05/13/byteball-flaws/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/13/byteball-flaws/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/05/13/byteball-flaws/" class="leancloud_visitors" data-flag-title="Byteball目前存在的一些问题及改进方向">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Byteball是一种基于DAG技术的新型数字资产平台，它不仅支持P2P支付，还支持智能合约、预言机、隐私资产、ICO等功能。Byteball的钱包设计得十分强大，并且人性化。但通过对Byteball的仔细研究会发现，其在设计和实现上还是存在一定的缺陷。如果能很好地解决这些问题，Byteball必将跻身主流的数字资产平台。</p>
<h2 id="网络性能问题"><a href="#网络性能问题" class="headerlink" title="网络性能问题"></a>网络性能问题</h2><p>一份对byteball主网的最新测试给出了三点结论：</p>
<ol>
<li>交易处理速度仅能达到15TPS左右；</li>
<li>网络容易遭受DOS攻击，大量突发式的恶意交易会阻塞网络，降低网络的交易处理速度；</li>
<li>随着交易数量增加，交易确认时间可以保持平稳。</li>
</ol>
<p>作为DAG基础链，这个压力测试挺让人失望的，这显然没有充分发挥DAG技术的优势。不同于传统区块链交易处理速度受限于区块大小，Byteball网络的交易处理速度与代码执行速度、网络传输时延、硬件处理能力等都可能有关系。创始人Tony在Slack频道中承认byteball代码实现中大量的SQL操作增加了处理时延，这可能是影响byteball处理性能的重要原因。</p>
<blockquote>
<p><strong>那么，是否可以优化byteball的数据库设计及SQL操作？</strong></p>
</blockquote>
<p>DAG作为Byteball底层数据结构，其相应的数据很自然地应该使用图数据库进行存储。这需要重新设计Byteball的数据库，并重写大量Byteball底层的代码。同时，还需要一个高性能的serverless embedded graph database，比如基于leveldb的<a href="https://github.com/levelgraph/levelgraph" target="_blank" rel="noopener">levelgraph</a>。采用图数据库的一个最大好处是可以减少大量的SQL多表联合查询，并简化确认交易时的多级回溯操作，从而提高其处理性能。</p>
<h2 id="Hub节点问题"><a href="#Hub节点问题" class="headerlink" title="Hub节点问题"></a>Hub节点问题</h2><p>在Byteball网络中，Hub节点是网络中的骨干节点，它们之间构成P2P网络，其它节点需要通过它们进行相互通信。全网中可以存在多个Hub，用户可以自由选择其想要接入的Hub。这里需要说明的是，Relay节点具有与Hub节点类似的功能，只是不提供端到端的信息加密服务。在下面的讨论中，不特殊说明的话，将Hub/Relay节点统一称为Hub节点。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-05-12-byteball-network.png" alt="byteball网络结构"></p>
<p>从技术角度来讲，Hub节点是在全节点钱包的基础上，提供一些额外的数据转发功能。从数据存储的角度来看：轻钱包是不保存完整的账本数据的；全节点钱包和见证人保存完整的账本数据，但仅供它们自己使用；只有Hub节点保存完整的账本数据，并与其它的节点进行共享。</p>
<p>试想如果Hub节点作恶，它可以拒绝为与其连接的钱包等其它节点提供Byteball网络接入服务，拒绝为它们广播、共享交易数据。还有一种极端情况，如果所有见证人节点都连接在同一个Hub节点上，那么它将成为整个网络中的霸主。其它Hub节点如果不能得到该Hub节点的服务，则其它Hub节点广播的所有交易都无法得到网络的确认。这也就是说，那些Hub节点都无法正常工作了。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-05-13-byteball-hub-flaw.png" alt="Hub节点中心化"></p>
<p>Hub节点在账本数据的有效性、可靠性及安全性方面起着十分重要的作用。然而，在Byteball目前的实现下，Hub节点是完全没有收益激励的，同时还要承担相应的服务器开支。实际上，目前全网主要使用的还是官方提供的Hub节点（wss://byteball.org/bb/)。</p>
<blockquote>
<p><strong>那么，对于扮演如此重要角色的Hub节点，是否应该给予经济激励，并限制其部分权力？</strong></p>
</blockquote>
<p>设计经济激励的目的是为了让更多的人愿意运行Hub节点，为整个网络更公平有效的服务。同时，为了相对性地限制Hub节点的权力，建议提升见证人节点、全节点钱包在网络结构中的地位，即它们之间可以组成P2P网络。</p>
<h2 id="见证人的问题"><a href="#见证人的问题" class="headerlink" title="见证人的问题"></a>见证人的问题</h2><p>Witnesses是Byteball用来实现全网共识的，见证人通过不断地发送交易来确认其他用户的交易。Byteball对见证人提出的要求是：现实世界中的知名用户或机构，以保证其具有良好的信誉。一旦见证人发生作恶行为，那么他将名誉扫地。要求如此严格，但见证人只能获取少量的手续费。试问谁愿意将自己的名誉压在Byteball这样一个数字资产平台上呢？目前的实际情况是，大部分的见证人节点掌握在创始人Tony手中。</p>
<p>Byteball的共识机制的一个基本思想是选取一条主链，所有单元都可以依据这条主链来定序，从而解决双花问题。形象的来说，这条主链类似一条高速公路，连接在主链上的其它分支为省道，通过这种方式可以大大地提高网络处理效率。Byteball是通过见证人的方式选择主链的，主链上的交易受到大多数见证人的认可。当然，选择主链也可以有其它方式，比如使用POW方式，最近热门的<a href="https://xdag.io/" target="_blank" rel="noopener">xdag</a>采用的就是这样的思想。</p>
<blockquote>
<p><strong>那么，Byteball的共识机制是否可以演进为基于POS的见证机制？</strong></p>
</blockquote>
<p>这意味着，见证人列表不是固定不变的，也不是由用户手工进行选择的。见证人列表通过POS的方式产生，以一定的时间间隔生成见证人列表，并基于此进行共识。在POS中，拥有资产越多的用户更倾向于维护网络的正常运转。</p>
<h2 id="手续费问题"><a href="#手续费问题" class="headerlink" title="手续费问题"></a>手续费问题</h2><p>Byteball中的交易手续费分为两部分，一部分给见证人，另一部分给其子单元。</p>
<p>分给见证人的交易手续费称为payload commission，它与交易存储内容所占字节数成正比。然而，实际上交易存储内容的大小对于见证人是没有区别，见证人需要做的只是持续产生交易单元就可以。</p>
<p>分给子单元的交易手续费称为header commission，它基本上是个固定值。它设计的目的是为了让用户尽量选择新产生的交易单元，从而保持DAG的宽度不至于太大。其实，普通用户收到少量的手续费让人很疑惑。虽然，用户行为在确认交易单元上做出了贡献，但通常这属于偶发行为。而像Hub这类承担着网络运行重任的节点却得不到任何激励。至于限制DAG的宽度，完全可以在选择父节点时，给新产生节点赋予更高的权重。</p>
<blockquote>
<p><strong>那么，是否可以重新设计手续费结构，将其分配给那些维护网络正常运行的节点？</strong></p>
</blockquote>
<p>上面我们讨论到了对于Hub节点的激励，手续费中应该加入给Hub节点的部分；同时，去除分给子单元的部分，而代以更好的父节点选择算法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/15/blockchain-system-view/" itemprop="url">
                  区块链系统观
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-15T15:09:55+08:00" content="2018-04-15">
              2018-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/04/15/blockchain-system-view/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/04/15/blockchain-system-view/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/04/15/blockchain-system-view/" class="leancloud_visitors" data-flag-title="区块链系统观">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从计算机原理角度来看区块链：</p>
<ol>
<li>全网无中心分布的计算机是底层硬件，它们构成分布式计算机，负责运算与存储；</li>
<li>区块链是分布式计算机的操作系统，它采用一定机制使得底层硬件协调工作起来，并达成共识，即得到一致的运算结果，比如第一代的Bitcoin、第二代的Ethereum等；</li>
<li>在冯诺依曼计算机结构里，程序与数据是都放在存储器中，区块链中的“文件系统”可以用来存储程序与数据，但是十分昂贵；</li>
<li>IPFS作为去中心化世界的http协议，可以用来大量存储文件与内容，从而区块链获得额外的廉价存储空间。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/30/byteball5/" itemprop="url">
                  DAG Blockchain之Byteball原理解析（五）-完结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-30T18:10:55+08:00" content="2018-01-30">
              2018-01-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/30/byteball5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/30/byteball5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/30/byteball5/" class="leancloud_visitors" data-flag-title="DAG Blockchain之Byteball原理解析（五）-完结">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Byteball的应用"><a href="#Byteball的应用" class="headerlink" title="Byteball的应用"></a>Byteball的应用</h2><h3 id="数字资产"><a href="#数字资产" class="headerlink" title="数字资产"></a>数字资产</h3><p>Byteball本质上是基于DAG的分布式数据库，数据状态一旦确定则不可逆转。在各种类型的数据中，具有社会普遍意义的数据是比较有价值的，比如个人资产数据。在Byteball中，资产可以发布、转移以及交换，类似于Byteball的基本货币<code>bytes</code>。资产可以代表任何有价值的东西，比如债务、股票、会员积分、通话时间、商品、其它加密货币等。</p>
<p>定义新资产的消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "asset",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        cap: 1000000,</span><br><span class="line">        is_private: false,</span><br><span class="line">        is_transferrable: true,</span><br><span class="line">        auto_destroy: false,</span><br><span class="line">        fixed_denominations: false,</span><br><span class="line">        issued_by_definer_only: true,</span><br><span class="line">        cosigned_by_definer: false,</span><br><span class="line">        spender_name_attested: true,</span><br><span class="line">        attestors: [</span><br><span class="line">          "2QLYLKHMUG237QG36Z6AWLVH4KQ4MEY6",</span><br><span class="line">          <span class="string">"X5ZHWBYBF4TUYS35HU3ROVDQJC772ZMG"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义新资产时，可以设置以下属性：</p>
<ul>
<li><code>cap</code>：资产总量，比如<code>bytes</code>的总量为$10^{15}$</li>
<li><code>is_private</code>：资产转移是否公开，比如<code>bytes</code>为公开</li>
<li><code>is_transferrable</code>：资产是否可以在无发行方允许的条件下进行流通，如果不可流通，则资产的收发方中必须有发行方，比如<code>bytes</code>为可流通</li>
<li><code>auto_destroy</code>：资产在发送回发行方时是否自动销毁，比如<code>bytes</code>为不自动销毁</li>
<li><code>fixed_denominations</code>：资产是否以固定面额进行流通（类似纸币），比如<code>bytes</code>可以以任意金额流通</li>
<li><code>issued_by_definer_only</code>：资产是否仅由发行方发布，比如<code>bytes</code>均在创世单元中发布</li>
<li><code>cosigned_by_definer</code>：资产在每次转移时是否必须由发行方共同签名，比如<code>bytes</code>是不需要的</li>
<li><code>spender_attested</code>：资产在使用时用户是否需要通过认证，比如<code>bytes</code>是不需要的</li>
<li><code>attestors</code>：受资产发行方认可的认证地址，可以在后续过程中修改</li>
<li><code>denominations</code>：如果资产具有固定面额，定义面额种类以及各类别总量</li>
<li><code>transfer_condition</code>：资产转移需要的额外条件，语法与地址定义脚本相同（除了不使用<code>sig</code>之外）</li>
<li><code>issue_condition</code>：资产发布需要的额外条件</li>
</ul>
<p>在定义资产时，每个单元中最多只能有一条<code>asset</code>消息。当资产定义单元发布后，后续都通过引用该单元的hash来引用该资产。资产只能定义一次，除了<code>attestors</code>之外均不能进行修改。资产定义的解释权在发行方，其具体含义由其进行解释。资产定义中的不同属性的组合可以适用不同的场景。</p>
<p>发布资产的消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "payment",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        asset: "hash of unit where the asset was defined",</span><br><span class="line">        inputs: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: "issue",</span><br><span class="line">            amount: 1000000,</span><br><span class="line">            serial_number: 1,</span><br><span class="line">            address: "ISSUER ADDRESS" // only when multi-authored</span><br><span class="line">          &#125;,</span><br><span class="line">          ...</span><br><span class="line">        ],</span><br><span class="line">        outputs: [</span><br><span class="line">          &#123;</span><br><span class="line">            address: "BENEFICIARY ADDRESS",</span><br><span class="line">            amount: 12345</span><br><span class="line">          &#125;,</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总量有限的资产必须在一个交易中全部发布，比如，所有的<code>bytes</code>都是在创世单元中发布的。如果资产总量有限，发布时<code>serial_number</code>必须为1；如果资产总量不受限，每次发布时<code>serial_number</code>必须保证不同。</p>
<p>转移资产与<code>bytes</code>类似，只是需要加上资产的ID，其消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "payment",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        asset: "hash of unit where the asset was defined",</span><br><span class="line">        inputs: [</span><br><span class="line">          &#123;</span><br><span class="line">            unit: "hash of source unit",</span><br><span class="line">            message_index: 0,</span><br><span class="line">            output_index: 1</span><br><span class="line">          &#125;,</span><br><span class="line">          ...</span><br><span class="line">        ],</span><br><span class="line">        outputs: [</span><br><span class="line">          &#123;</span><br><span class="line">            address: "BENEFICIARY ADDRESS",</span><br><span class="line">            amount: 12345</span><br><span class="line">          &#125;,</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐私资产"><a href="#隐私资产" class="headerlink" title="隐私资产"></a>隐私资产</h3><p>公开资产在转移过程中，其内容在交易中是完全公开的。而对于隐私财产，在转移时，仅发送特定时间点资产转移的证据；同时，发送者通过私有通道把资产发送给接收者；接收者可以通过区块链上的资产转移证据来验证是否得到该笔资产。</p>
<p>为了解决双花问题，需要在单元增加新的字段<code>spend_proof</code>，要求：</p>
<ul>
<li>它仅依赖于其所花费的输出，相同的输出将产生相同的<code>spend_proof</code></li>
<li>无法通过它逆向推断出所花费输出的任何信息</li>
</ul>
<p>例如采用如下方式生成<code>spend_proof</code>： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spend_proof = hash(&#123;</span><br><span class="line">  asset: payload.asset,</span><br><span class="line">  unit: input.unit,</span><br><span class="line">  message_index: input.message_index,</span><br><span class="line">  output_index: input.output_index,</span><br><span class="line">  address: src_output.address,</span><br><span class="line">  amount: src_output.amount,</span><br><span class="line">  blinding: src_output.blinding</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其中，<code>payload.asset</code>表示需要转移的资产，<code>input</code>则表示花费输出<code>src_output</code>的输入。隐私资产的输出必须包含扰乱因子<code>blinding</code>，它使得无法通过<code>spend_proof</code>来逆向推到出其使用了哪个输出。</p>
<p>对于隐私资产的发行来讲，其<code>spend_proof</code>为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spend_proof = hash(&#123;</span><br><span class="line">  asset: payload.asset,</span><br><span class="line">  address: "ISSUER ADDRESS",</span><br><span class="line">  serial_number: input.serial_number, // always 1 for capped assets</span><br><span class="line">  amount: input.amount, // issue amount</span><br><span class="line">  denomination: 1 // always 1 for arbitrary-amounts payments</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在发行隐私资产时，由于需要公开表明已发行该资产，因此不需要添加扰乱因子。在资产传递过程中，发送者已知扰乱因子，虽然他可以知道接收者是否花费了这笔资产，但是他无法知道这笔资产的下一个接收者是谁，也就无法继续跟踪该笔资产的进一步流向了。</p>
<p><code>spend_proof</code>需要添加到区块链单元中，其格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  spend_proofs: [</span><br><span class="line">    &#123;</span><br><span class="line">      spend_proof: "the above hash in base64",</span><br><span class="line">      address: "SPENDING ADDRESS" // only if multi-authored</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在发送隐私资产时，发送者需要完成以下几件事情：</p>
<ul>
<li>对每个输出添加扰乱因子</li>
<li>将隐私资产通过私有通道发送给接收者，以及该资产传递所在的区块链单元</li>
<li>对于单元中每个输入，计算相应的<code>spend_proof</code>并加入单元中</li>
</ul>
<p>接收者需要检查两件事情：</p>
<ul>
<li>检查收到的隐私资产的<code>hash</code>值是否与区块链单元中的<code>payload_hash</code>相同</li>
<li>检查通过收到的隐私资产计算得到的<code>spend_proof</code>是否与区块链单元中的匹配</li>
</ul>
<p>接收者可以验证整个资产转移的过程，并能够回溯到该资产的发布单元。</p>
<p>Byteball中提供了一种隐私数字资产<code>blackbytes</code>，其定义如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  cap: 2,111,100,000,000,000,</span><br><span class="line">  is_private: true,</span><br><span class="line">  is_transferrable: true,</span><br><span class="line">  auto_destroy: false,</span><br><span class="line">  fixed_denominations: true,</span><br><span class="line">  issued_by_definer_only: true,</span><br><span class="line">  cosigned_by_definer: false,</span><br><span class="line">  spender_name_attested: false,</span><br><span class="line">  denominations: [</span><br><span class="line">    &#123;denomination: 1, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 2, count_coins: 20,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 5, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 10, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 20, count_coins: 20,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 50, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 100, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 200, count_coins: 20,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 500, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 1000, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 2000, count_coins: 20,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 5000, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 10000, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 20000, count_coins: 20,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 50000, count_coins: 10,000,000,000&#125;,</span><br><span class="line">    &#123;denomination: 100000, count_coins: 10,000,000,000&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="非结构化数据（文本）"><a href="#非结构化数据（文本）" class="headerlink" title="非结构化数据（文本）"></a>非结构化数据（文本）</h4><p>用户可以在Byteball中存储文本信息，消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "text",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: "any text"</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文本可以是任意内容：用户可以利用这个发布不能被篡改的公告、微博等等；也可以存储一些非明文的内容，比如合约的hash值之类的。</p>
<h4 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h4><p>用户也可以使用Byteball存储任意的结构化数据，消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "data",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        key: "value",</span><br><span class="line">        another_key: &#123;</span><br><span class="line">          subkey: "other value",</span><br><span class="line">          another_subkey: 232</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     ...</span><br><span class="line">  ],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><p>用户可以使用Byteball发起投票，消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "poll",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        question: "Should the United Kingdom remain a member of the European Union or leave the European Union?",</span><br><span class="line">        choices: ["Leave", "Remain"]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，用户可以响应投票，其消息格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "vote",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        unit: "hash of the unit where the poll was defined",</span><br><span class="line">        choice: "Leave"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>投票的有效性需要由发起投票方来决定，Byteball仅仅检查投票选项是否在给定集合内。比如，如果发起投票方要求只允许经过认证的或在白名单上的用户进行投票，那些无效的投票也会被Byteball记录，需要由发起方自行判别。</p>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>用户可以通过Byteball发布和存储个人信息，消息格式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">  ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "profile",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        name: "Joe Average",</span><br><span class="line">        emails: ["joe@example.com", "joe@domain.com"],</span><br><span class="line">        twitter: "joe"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户可以发布任意的个人信息，但是其真实性是无法保证的，只有通过认证的信息才是可信的。</p>
<p>认证消息用于确定用户发布的个人信息的真实性，其消息格式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "attestation",</span><br><span class="line">      payload_location: "inline",</span><br><span class="line">      payload_hash: "hash of payload",</span><br><span class="line">      payload: &#123;</span><br><span class="line">        address: "ADDRESS OF THE SUBJECT"</span><br><span class="line">        profile: &#123;</span><br><span class="line">          name: "Joe Average",</span><br><span class="line">          emails: ["joe@example.com"]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证消息中的个人信息不一定与用户自己发布的信息一致，事实上，用户甚至没有自己发布过个人信息。</p>
<p>Byteball中的认证者类似于现实世界中的实名认证，认证某个地址是归属于某个个人或组织。认证方可以向被认证方收取少量费用。一般来讲，见证人节点是需要通过认证的，这样可以提高手信任度。被认证方可以选择不公布认证信息，而只在Byteball中保存认证证据，并在合适的时机公布。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Byteball是一种基于DAG结构的不可逆分布式数据库，它可以存储任何有价值的数据。Byteball中每一个新的数据单元都间接地确认了之前所有数据单元的存在性。对已达到稳定状态的数据单元的修改将变得不可实现。</p>
<p>相比于BTC和ETH，Byteball使用了DAG结构作为底层，并使用见证人作为共识机制，从而具有以下特点：</p>
<ul>
<li>没有区块，只有交易单元，确认速度快</li>
<li>极少的手续费</li>
<li>交易单元具有最终状态</li>
</ul>
<p>Byteball中发行了一种用于支付存储的货币<code>bytes</code>，支付费用与所需要存储的数据大小相关。自由开发者可以在Byteball平台上自由开发各种应用，根据不同的应用场景发布相应的数字资产。在Byteball上面可以轻松地实现去中心化交易所、互助保险、赌球、彩票、投票、认证等等功能。Byteball还提供了类似telegram的加密端到端通道，可以实现用户之间的隐私通信。Byteball最与众不同的是，它提供了一种隐私数字资产<code>blackbytes</code>，可以完整地保护使用者的隐私信息。</p>
<p>总的来说，不管从使用技术的先进性，还是其提供功能的多样性，Byteball都是区块链领域中的佼佼者。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/26/byteball4/" itemprop="url">
                  DAG Blockchain之Byteball原理解析（四）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-26T23:09:55+08:00" content="2018-01-26">
              2018-01-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/26/byteball4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/26/byteball4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/26/byteball4/" class="leancloud_visitors" data-flag-title="DAG Blockchain之Byteball原理解析（四）">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Byteball的网络结构"><a href="#Byteball的网络结构" class="headerlink" title="Byteball的网络结构"></a>Byteball的网络结构</h2><p>从节点功能角度来讲，Byteball网络节点可以分为中继节点（Relay）、中枢节点（Hub）、播报节点（Oracle）、见证人节点（Witness）、钱包节点（Wallet）：</p>
<ul>
<li>中继节点（Relay）：负责向与其连接的节点转发单元，存储整个Byteball区块链数据库，但它本身不保存任何私钥，也不发送任何单元；</li>
<li>中枢节点（Hub）：负责为连接到它的设备提供端到端的加密消息传输通道，用于比如收发私密资产、多签名交易、聊天信息等，其它功能与中继节点相同，默认的Hub地址为<code>wss://byteball.org/bb</code>；</li>
<li>播报节点（Oracle）：负责不间断地向Byteball网络播报数据，数据可以是时间、价格、甚至是Bitcoin交易；</li>
<li>见证人节点（Witness）：负责不间断地以固定地址发送单元，任何满足该条件的节点都有可能成为见证人；</li>
<li>钱包节点（Wallet）：负责与用户交互，收发交易、消息等。</li>
</ul>
<p>下图给出了Byteball网络结构的示意图：</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-01-25-byteball_network-1.png" alt="Byteball网络结构"></p>
<h3 id="轻节点及其验证过程"><a href="#轻节点及其验证过程" class="headerlink" title="轻节点及其验证过程"></a>轻节点及其验证过程</h3><p>从是否存储了完整的区块链数据角度来讲，节点也可以分为全节点和轻节点，全节点保存了完整的区块链数据，而轻节点没有。用户在安装钱包时可以选择是使用全节点还是轻节点。轻节点仅存储与其地址相关的那些单元，它需要从全节点上下载所需要的数据，请求条件包括它信任的见证人列表以及它关注的地址。</p>
<blockquote>
<p><strong>跳跃列表：</strong>假设直接位于主链上的球的MCI为$i$，如果$i\bmod10=0$，则该球具有跳跃列表（<code>skiplist_balls</code>），跳跃列表中的值指向之前的球；对于$i$尾数具有的每一个$0$，跳跃列表中都有一个MCI值与之对应；跳跃列表中的MCI值等于在保持尾数$0$个数相同的情况下最接近$i$的MCI，比如$i=3000$时，对应的跳跃列表为$[2990, 2900, 2000]$。</p>
<p><strong>跳跃距离：</strong>对于跳跃列表中的MCI值，它与当前球的MCI值的差值称为跳跃距离。</p>
<p><strong>最近的球：</strong>当前节点已知的距离当前时刻最近的球（<code>last_ball</code>），每个单元在发送时必须包含其已知的最近的球。</p>
</blockquote>
<p>全节点接收到轻节点发送的见证人列表和关注地址，在其存储单元的数据库中搜索与轻节点关注地址相关的单元。同时，对于每一个相关的单元，全节点构造一条证据链，构造方法如下：</p>
<ol>
<li>沿着主链回溯，当已收集到轻节点给定见证人列表中的绝大部分见证人时停止（<strong>这是寻找见证人的过程</strong>），记录这些主链上的单元，记作单元集合$C$；</li>
<li>选择单元集合$C$中时间最早的单元（也是MCI最小的单元），获取其<code>last_ball</code>；</li>
<li>从<code>last_ball</code>这个单元开始沿着主链回溯，直至遇见包含<code>skiplist_balls</code>的球停止，记录这些主链上的球，记作球集合$B$；</li>
<li>使用<code>skiplist_balls</code>继续沿主链回溯，跳转到<code>skiplist_balls</code>中跳跃距离最大的球（<strong>这是不断加速跳跃的过程</strong>）；</li>
<li>重复步骤4，当下一次跳跃超过目标单元时，减小跳跃距离（<strong>这是降速跳跃的过程，极限情况下，不使用<code>skiplist_balls</code>回溯，只利用父单元进行回溯</strong>），直到目标单元停止。</li>
</ol>
<p>对于轻节点而言，全节点给出的证据链是可信的，主要有以下两个原因：</p>
<ol>
<li>证据链开始的那些单元包含了轻节点信任的见证人发出的单元；</li>
<li>证据链中的连接使用的是<code>parent_units</code>（寻找见证人过程）、<code>last_ball</code>、<code>skiplist_balls</code>、<code>parent_balls</code>。</li>
</ol>
<p>因此，通过证据链的方式，轻节点可以判断某个单元是否有效。</p>
<h3 id="端到端加密通道"><a href="#端到端加密通道" class="headerlink" title="端到端加密通道"></a>端到端加密通道</h3><p>中枢节点Hub用于为不同的用户设备之间提供可靠的端到端加密数据通道，有点类似邮件服务器。Hub为用户设备提供存储转发服务，用户设备可以选择连接到不同的Hub。用户设备使用websocket连接到到Hub，并采用TLS加密。Hub一旦收到发往某个设备地址的消息，它就会立即转发，转发成功后删除消息。</p>
<p>设备地址是用于标识用户设备的，从而接收其它设备发送的消息，类似于邮件地址。设备地址与钱包地址不同，可以在不同的设备上使用相同的钱包地址。每个设备保存一把永久性的私钥，其对应的公钥做Hash后进行BASE32编码得到设备地址。为了和钱包地址区分开来，设备地址在其开始位置添加0作为标识（0本身并不是BASE32字符）。完整的设备地址还要包括Hub名称，比如<code>DEVICEADDRESS@hubname.com</code>。当切换到不同的Hub是，<code>@</code>之间的地址是保持不变的。</p>
<p>假设发送消息的设备记作<code>sender</code>，接收消息的设备记作<code>receiver</code>，<code>receiver</code>所连接的Hub为<code>hub</code>。那么，当<code>sender</code>想要与<code>receiver</code>进行通信时，它需要进行以下操作：</p>
<ol>
<li><code>sender</code>修改其Hub地址为<code>hub</code>，默认情况下所有设备连接的都是<code>wss://byteball.org/bb</code>；</li>
<li><code>sender</code>与<code>receiver</code>进行配对，可以使用扫描二维码、配对字符串、或者使用<code>byteball://</code>起始的链接。</li>
</ol>
<p>所有设备之间的通信均采用了端到端加密（ECDH+AES）和数字签名（ECDSA）。作为通信的唯一中间人，Hub也无法查看或者修改消息内容，为了提高转发的安全性，设备会生成一个临时私钥，并将对应的公钥上传至它连接的Hub上。同时，设备可以定时地更换临时私钥和公钥。</p>
<p>因此，<code>sender</code>在向<code>receiver</code>发送消息时，它需要完成以下步骤：</p>
<ol>
<li>与<code>hub</code>连接；</li>
<li>从<code>hub</code>获取<code>receiver</code>的临时公钥；</li>
<li>生成一次性的密钥对；</li>
<li>根据一次性私钥和<code>receiver</code>的临时公钥生成ECDH密钥；</li>
<li>使用ECDH密钥对消息进行AES加密；</li>
<li>添加一次性公钥；</li>
<li>使用设备私钥对整个消息进行签名；</li>
<li>将消息发送给<code>hub</code></li>
</ol>
<p>对于<code>receiver</code>，它首先需要验证消息的签名，然后使用<code>sender</code>的一次性公钥和本地的临时私钥解密消息，从而获得消息的内容。</p>
<p>基于Hub的设备端到端加密消息通道可以用于设备之间通信，设备之间相互发送的消息不存入Byteball数据库中。用户可以利用该通道来发送加密文本消息、多签名交易、隐私资产（比如blackbytes）等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/byteball3/" itemprop="url">
                  DAG Blockchain之Byteball原理解析（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-19T22:09:55+08:00" content="2018-01-19">
              2018-01-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/01/19/byteball3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/19/byteball3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2018/01/19/byteball3/" class="leancloud_visitors" data-flag-title="DAG Blockchain之Byteball原理解析（三）">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Byteball的地址、脚本及合约"><a href="#Byteball的地址、脚本及合约" class="headerlink" title="Byteball的地址、脚本及合约"></a>Byteball的地址、脚本及合约</h2><h3 id="地址的定义"><a href="#地址的定义" class="headerlink" title="地址的定义"></a>地址的定义</h3><p>Byteball中用户使用地址进行收发交易。地址本质上对应的是一段具有特定含义的脚本，该脚本称为地址的定义。任何能够使地址定义脚本输出为真（也称作解锁该脚本）的人具有使用该地址资产的权限。与Bitcoin类似，最常用的地址定义脚本是公钥（采用BASE64编码），即具有相应私钥的人可以使用该地址的资产，比如</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"sig"</span>,&#123;<span class="attr">"pubkey"</span>:<span class="string">"Ald9tkgiUZQQ1djpZgv2ez7xf1ZvYAsTLhudhvn0931w"</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>对于地址定义脚本进行哈希，再加上校验位就得到了地址，Byteball的地址采用BASE32编码。Byteball地址的校验位并不是全部放在尾部，而是穿插着放在哈希值中间，防止有攻击者在地址中间进行恶意修改。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2018-01-19-byteball-address.png" alt=""></p>
<p>按照此流程，上面公钥脚本对应的地址为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A2WWHN7755YZVMXCBLMFWRSLKSZJN3FU</span><br></pre></td></tr></table></figure>
<p>如果地址仅用于接收交易，其定义脚本可以不对外公布。但是当用户首次使用该地址进行发送交易时，他需要在发送的单元中声明该地址的定义脚本，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123; </span><br><span class="line">  ...</span><br><span class="line">  authors: [ &#123;</span><br><span class="line">    address: 'DJ6LV5GPCLMGRW7ZB55IVGJRPDJPOQU6', </span><br><span class="line">    definition: [</span><br><span class="line">      "sig", &#123;"pubkey":"AsnvZ3w7N1lZGJ+P+bDZU0DgOwJcGJ51bjsWpEqfqBg6"&#125;</span><br><span class="line">    ], </span><br><span class="line">    authentifiers: &#123;</span><br><span class="line">      r: '3eQPIFiPVLRwBwEzxUR5thqn+zlFfLXUrzAmgemAqOk35UvDpa4h79Fd6TbPbGfb8VMiJzqdNGHCKyAjl786mw=='</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; ],</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>authentifiers</code>是用户采用私钥对除<code>authentifiers</code>之外的数据进行的签名。在用户使用该地址首次发送单元之后，它不允许再发送地址的定义。当然，只有在该地址的第一个单元到达稳定后，用户才可以发送后续单元。</p>
<p>用户可以在保持地址不变的条件下修改地址的定义脚本，用户需要发送消息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123; </span><br><span class="line">  ...</span><br><span class="line">  messages: [ </span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "address_definition_change",</span><br><span class="line">      definition_chash: "I4Z7KFNIYTPHPJ5CA5OFC273JQFSZPOX"</span><br><span class="line">    &#125;,</span><br><span class="line">    ... </span><br><span class="line">  ],</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>definition_chash</code>为新的地址定义脚本生成的地址。那么，下一个从原地址发出的单元有以下两条要求：</p>
<ol>
<li>必须把<code>address_definition_change</code>这个单元作为其<code>last_ball</code>；</li>
<li>在修改地址定义脚本后发出第一个单元时，需要把新的定义脚本作为第一条<code>message</code>。</li>
</ol>
<p>显然，新的地址定义脚本生成的地址跟原地址是不相同的。当用户迁移到新的设备上，同时想保持地址不变时，可以使用这种方式来修改地址定义脚本。</p>
<p>地址定义脚本中必须显式地（使用<code>sig</code>）或隐式地（使用<code>address</code>）包含至少一个<code>sig</code>。为了防止消耗过量的资源，脚本的操作总数限制在100以内，包括授权地址及脚本模板中的所有操作。</p>
<p>相比于Ethereum，Byteball的脚本语言的解释能力有限，它定义的几乎都是逻辑判断语句。但是，Byteball本身是为了提供给那些并不太懂编程的人群使用的，其语言必须便于理解且不容易出错。</p>
<h3 id="逻辑运算脚本"><a href="#逻辑运算脚本" class="headerlink" title="逻辑运算脚本"></a>逻辑运算脚本</h3><p><strong>与运算：</strong>当多个条件同时满足时，脚本输出为真。比如，同时需要两个私钥签名的脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"and"</span>, [</span><br><span class="line">  ["sig", &#123;pubkey: "one pubkey in base64"&#125;], </span><br><span class="line">  ["sig", &#123;pubkey: "another pubkey in base64"&#125;]</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p><strong>或运算：</strong>多个条件中有一个满足时，脚本输出为真。比如，仅需要<code>laptop</code>、<code>smartphone</code>或者<code>talet</code>中某一个私钥就可以解锁的脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>, [</span><br><span class="line">  ["sig", &#123;pubkey: "laptop pubkey"&#125;], </span><br><span class="line">  ["sig", &#123;pubkey: "smartphone pubkey"&#125;], </span><br><span class="line">  ["sig", &#123;pubkey: "tablet pubkey"&#125;]</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p><strong>非运算</strong>：脚本中不含<code>sig</code>、<code>hash</code>、<code>address</code>、<code>cosigned by</code>或者<code>in merkle</code>的条件可以进行非运算，比如</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"not"</span>, [</span><br><span class="line">  <span class="string">"in data feed"</span>, </span><br><span class="line">  [[<span class="string">"NOAA ADDRESS"</span>], <span class="string">"wind_speed"</span>, <span class="string">"&gt;"</span>, <span class="string">"200"</span>]</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p><strong>逻辑嵌套：</strong>逻辑运算可以嵌套使用。比如，必须同时拥有<code>smartphone</code>私钥以及<code>laptop</code>或者<code>tablet</code>中某一个私钥就可以解锁的脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"and"</span>, [</span><br><span class="line">  [<span class="string">"or"</span>, [</span><br><span class="line">    ["sig", &#123;pubkey: "laptop pubkey"&#125;],</span><br><span class="line">    ["sig", &#123;pubkey: "tablet pubkey"&#125;] </span><br><span class="line">  ]],</span><br><span class="line">  ["sig", &#123;pubkey: "smartphone pubkey"&#125;] </span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p><strong>最小数量运算：</strong>当满足条件的个数超过门限时，脚本输出为真。比如，具有2个以上私钥就可以解锁的脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"r of set"</span>, &#123; </span><br><span class="line">  required: 2,</span><br><span class="line">  set: [</span><br><span class="line">    ["sig", &#123;pubkey: "laptop pubkey"&#125;], </span><br><span class="line">    ["sig", &#123;pubkey: "smartphone pubkey"&#125;], </span><br><span class="line">    ["sig", &#123;pubkey: "tablet pubkey"&#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>最低权重运算：</strong>当满足条件的权重值超过门限时，脚本输出为真。比如，当几个私钥签名的权重之和大于50时可以解锁的脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"weighted and"</span>, &#123; </span><br><span class="line">  required: 50,</span><br><span class="line">  set: [</span><br><span class="line">    &#123;weight: 40, value: ["sig", &#123;pubkey: "CEO pubkey"&#125;] &#125;, </span><br><span class="line">    &#123;weight: 20, value: ["sig", &#123;pubkey: "COO pubkey"&#125;] &#125;, </span><br><span class="line">    &#123;weight: 20, value: ["sig", &#123;pubkey: "CFO pubkey"&#125;] &#125;, </span><br><span class="line">    &#123;weight: 20, value: ["sig", &#123;pubkey: "CTO pubkey"&#125;] &#125;</span><br><span class="line">  ] </span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="地址授权脚本"><a href="#地址授权脚本" class="headerlink" title="地址授权脚本"></a>地址授权脚本</h3><p>授权使用其它地址来解锁脚本，其定义的语法为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"and"</span>, [</span><br><span class="line">  [<span class="string">"address"</span>, <span class="string">"ADDRESS 1 IN BASE32"</span>], </span><br><span class="line">  [<span class="string">"address"</span>, <span class="string">"ADDRESS 2 IN BASE32"</span>]</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>这可以很方便地用来构造共享控制的地址。比如，上面给出的地址定义脚本生成的地址将由<code>ADDRESS1</code>和<code>ADDRESS2</code>共同控制。</p>
<h3 id="共同签名脚本"><a href="#共同签名脚本" class="headerlink" title="共同签名脚本"></a>共同签名脚本</h3><p>要求与另一个地址共同签名才可以解锁脚本</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"cosigned by"</span>, <span class="string">"ANOTHER ADDRESS IN BASE32"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="地址已用脚本"><a href="#地址已用脚本" class="headerlink" title="地址已用脚本"></a>地址已用脚本</h3><p>要求由某个地址发出的单元至少有一个成为<code>last_ball_unit</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"seen address"</span>, <span class="string">"ANOTHER ADDRESS IN BASE32"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="数据订阅脚本"><a href="#数据订阅脚本" class="headerlink" title="数据订阅脚本"></a>数据订阅脚本</h3><p>通过订阅的数据是否符合条件来解锁脚本，其语法格式为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"in data feed"</span>, [</span><br><span class="line">  [<span class="string">"ADDRESS1"</span>, <span class="string">"ADDRESS2"</span>, ...], </span><br><span class="line">   <span class="string">"data feed name"</span>,</span><br><span class="line">   <span class="string">"="</span>,</span><br><span class="line">   <span class="string">"expected value"</span></span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>上述脚本表示：当数据源地址<code>ADDRESS1</code>、<code>ADDRESS2</code>等中某个地址发出的消息中订阅数据<code>data feed name</code>等于<code>expected value</code>时，脚本输出为真。</p>
<p>地址发出的数据订阅消息格式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unit: &#123;</span><br><span class="line">  ...</span><br><span class="line">  messages: [</span><br><span class="line">  	...</span><br><span class="line">    &#123;</span><br><span class="line">      app: "data_feed", </span><br><span class="line">  	  payload_location: "inline", </span><br><span class="line">      payload_hash: "hash of payload", </span><br><span class="line">      payload: &#123;</span><br><span class="line">        "data feed name": "value",</span><br><span class="line">        "another data feed name": "value2",</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对赌合约"><a href="#对赌合约" class="headerlink" title="对赌合约"></a>对赌合约</h4><p>当某个地址可以作为可靠的数据订阅源时，用户可以使用其作为外部数据条件来构造<strong>合约</strong>。比如，</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>, [</span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"ADDRESS 1"</span>],</span><br><span class="line">    [<span class="string">"in data feed"</span>, [[<span class="string">"EXCHANGE ADDRESS"</span>], <span class="string">"EURUSD"</span>, <span class="string">"&gt;"</span>, <span class="string">"1.1500"</span>]]</span><br><span class="line">  ]], </span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"ADDRESS 2"</span>],</span><br><span class="line">    [<span class="string">"in data feed"</span>, [[<span class="string">"TIMESTAMPER ADDRESS"</span>], <span class="string">"datetime"</span>, <span class="string">"&gt;"</span>, <span class="string">"2016-10-01 00:00:00"</span>]]</span><br><span class="line">  ]] </span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>上述脚本给出了<code>ADDRESS 1</code>和<code>ADDRESS 2</code>之间的一个简单合约，假设其对应的地址为<code>ADDRESS X</code>。当<code>EXCHANGE ADDRESS</code>发布的汇率数据<code>EURUSD</code>大于<code>1.1500</code>时，仅使用<code>ADDRESS 1</code>的私钥就可以取走<code>ADDRESS X</code>中的资产。而当<code>TIMESTAMPER ADDRESS</code>发布的时间数据<code>datetime</code>大于<code>2016-10-01 00:00:00</code>时，仅使用<code>ADDRESS 2</code>的私钥就可以取走<code>ADDRESS X</code>中的资产。也就是说，上述脚本定义的是对赌合约：如果<code>2016-10-01 00:00:00</code>之前<code>EURUSD</code>汇率超过<code>1.1500</code>，地址<code>ADDRESS 1</code>获胜，否则地址<code>ADDRESS 2</code>获胜。</p>
<h4 id="商品合约"><a href="#商品合约" class="headerlink" title="商品合约"></a>商品合约</h4><p>当顾客购买商品时，也可以使用上述方式来制定合约，比如</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>, [</span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"MERCHANT ADDRESS"</span>],</span><br><span class="line">    [<span class="string">"in data feed"</span>, [[<span class="string">"FEDEX ADDRESS"</span>], <span class="string">"tracking"</span>, <span class="string">"="</span>, <span class="string">"123456"</span>]]</span><br><span class="line">  ]], </span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"BUYER ADDRESS"</span>],</span><br><span class="line">    [<span class="string">"in data feed"</span>, [[<span class="string">"TIMESTAMPER ADDRESS"</span>], <span class="string">"datetime"</span>, <span class="string">"&gt;"</span>, <span class="string">"2016-10-01 00:00:00"</span>]]</span><br><span class="line">  ]] </span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>上述脚本给出了顾客<code>BUYER ADDRESS</code>和商户<code>MERCHANT ADDRESS</code>之间的合约，假设其对应的地址为<code>ADDRESS Y</code>。顾客在购买商品时，将款项打入地址<code>ADDRESS Y</code>。如果快递公司<code>FEDEX ADDRESS</code>发布数据表明相应的快递已签收，则商户<code>MERCHANT ADDRESS</code>可以从<code>ADDRESS Y</code>中取走货款；如果<code>TIMERSTAMPER ADDRESS</code>发布的时间数据<code>datetime</code>大于<code>2016-10-01 00:00:00</code>时，则顾客<code>BUYER ADDRESS</code>可以从<code>ADDRESS Y</code>中取回货款。</p>
<p>上述场景中，快递公司需要对每一个快递都发布其签收状态数据，这将需要发布大量的数据。Merkle数据订阅可以降低需要发布的数据量。只需要核实关心的<code>hash</code>值出现在数据源地址发布的Merkle树中时，即可证明该事件已发生。其定义语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"in merkle"</span>, [</span><br><span class="line">  [<span class="string">"ADDRESS1"</span>, <span class="string">"ADDRESS2"</span>, ...], </span><br><span class="line">   <span class="string">"data feed name"</span>,</span><br><span class="line">   <span class="string">"hash of expected value"</span></span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>此时，快递公司只需要定期将一大批快递状态构造Merkle树，并发布Merkle根即可。商户可以通过相应快递的Merkle路径来解锁Merkle数据订阅的脚本。</p>
<h3 id="单元约束脚本"><a href="#单元约束脚本" class="headerlink" title="单元约束脚本"></a>单元约束脚本</h3><p>脚本可以对相应地址发出的单元数据进行约束，其定义格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">['has', &#123;</span><br><span class="line">  what: 'input'|'output',</span><br><span class="line">  asset: 'assetID in base64 or "base" for bytes', </span><br><span class="line">  type: 'transfer'|'issue',</span><br><span class="line">  own_funds: true,</span><br><span class="line">  amount_at_least: 123,</span><br><span class="line">  amount_at_most: 123,</span><br><span class="line">  amount: 123,</span><br><span class="line">  address: 'INPUT OR OUTPUT ADDRESS IN BASE32'</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>上述脚本要求单元至少有一个输入/输出满足后续定义所有的条件。特别地，可以使用<code>has one</code>来强制要求有且仅有一个输入/输出满足后续所有条件。</p>
<p>其它类似的约束还有求和约束，要求输入/输出之和满足特定条件，其格式为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">['sum', &#123;</span><br><span class="line">  filter: &#123;</span><br><span class="line">    what: 'input'|'output',</span><br><span class="line">    asset: 'asset or base', </span><br><span class="line">    type: 'transfer'|'issue', </span><br><span class="line">    own_funds: true,</span><br><span class="line">    address: 'ADDRESS IN BASE32' </span><br><span class="line">  &#125;,</span><br><span class="line">  at_least: 120, </span><br><span class="line">  at_most: 130, </span><br><span class="line">  equals: 123</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h4 id="交易合约"><a href="#交易合约" class="headerlink" title="交易合约"></a>交易合约</h4><p>单元约束脚本可以用来实现去中心化交易。假设用户<code>USER ADDRESS</code>希望使用不高于<code>1000bytes</code>的价格购买<code>1200units</code>的其它资产。用户可以发送<code>1000bytes</code>至如下脚本定义的地址上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>, [</span><br><span class="line">  [<span class="string">"address"</span>, <span class="string">"USER ADDRESS"</span>], </span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"EXCHANGE ADDRESS"</span>], </span><br><span class="line">    [<span class="string">"has"</span>, &#123;</span><br><span class="line">      what: "output",</span><br><span class="line">      asset: "ID of alternative asset", </span><br><span class="line">      amount_at_least: 1200,</span><br><span class="line">      address: "USER ADDRESS"</span><br><span class="line">    &#125;] </span><br><span class="line">  ]]</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>或逻辑<code>or</code>的第一个条件表明，在未成交之前，用户可以随时取回他的<code>1000bytes</code>。或逻辑<code>or</code>的第二个条件表明，其他用户可以使用<code>EXCHANGE ADDRESS</code>地址私钥来取走着<code>1000bytes</code>，只要他同时在同一单元中将<code>1200units</code>其它资产输出到<code>USER ADDRESS</code>。通过这种方式，用户之间可以实现不同资产之间的交易。</p>
<h4 id="借贷合约"><a href="#借贷合约" class="headerlink" title="借贷合约"></a>借贷合约</h4><p>单元约束脚本还可以用来实现抵押借贷。假设借款人抵押某种资产借贷<code>10000bytes</code>，那么借款人和借贷人可以共同签名一笔交易，其中借贷人将<code>bytes</code>发送给借款人，同时借款人将抵押资产转入以下脚本定义的地址上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"or"</span>, [</span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"LENDER ADDRESS"</span>],</span><br><span class="line">    [<span class="string">"in data feed"</span>, [[<span class="string">"TIMESTAMPER ADDRESS"</span>], <span class="string">"datetime"</span>, <span class="string">"&gt;"</span>, <span class="string">"2017-06-01 00:00:00"</span>]]</span><br><span class="line">  ]], </span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"BORROWER ADDRESS"</span>], </span><br><span class="line">    [<span class="string">"has"</span>, &#123;</span><br><span class="line">      what: "output",</span><br><span class="line">      asset: "base",</span><br><span class="line">      amount: 10000,</span><br><span class="line">      address: "LENDER ADDRESS"</span><br><span class="line">    &#125;] </span><br><span class="line">  ]],</span><br><span class="line">  [<span class="string">"and"</span>, [</span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"LENDER ADDRESS"</span>], </span><br><span class="line">    [<span class="string">"address"</span>, <span class="string">"BORROWER ADDRESS"</span>]</span><br><span class="line">  ]] </span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>上述脚本包括了三层含义：</p>
<ol>
<li>当时间超过<code>2017-06-01 00:00:00</code>时，借贷人可以取走抵押资产；</li>
<li>当借款人归还<code>10000bytes</code>至借贷人地址<code>LENDER ADDRESS</code>时，借款人可以取回抵押资产；</li>
<li>借贷人和借款人可以协商解除合约。</li>
</ol>
<h3 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h3><p>通过预先设定的脚本模板可以很方便地定义脚本，只需要对模板中的参数进行修改即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"definition template"</span>, [</span><br><span class="line">  <span class="string">"hash of unit where the template was defined"</span>, </span><br><span class="line">  &#123;param1: "value1", param2: "value2"&#125;</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>脚本模板需要在单元中发送<code>app=’definition_template’</code>的消息，并且需要单元到达稳定状态后，脚本模板才可以使用。消息内容与普通的地址定义脚本相同，参数使用<code>@param1</code>及<code>@param2</code>表示。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/19/byteball2/" itemprop="url">
                  DAG Blockchain之Byteball原理解析（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-19T00:09:55+08:00" content="2017-12-19">
              2017-12-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/谈点区块链/" itemprop="url" rel="index">
                    <span itemprop="name">谈点区块链</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/19/byteball2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/19/byteball2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/12/19/byteball2/" class="leancloud_visitors" data-flag-title="DAG Blockchain之Byteball原理解析（二）">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Byteball的共识算法"><a href="#Byteball的共识算法" class="headerlink" title="Byteball的共识算法"></a>Byteball的共识算法</h2><h3 id="主链"><a href="#主链" class="headerlink" title="主链"></a>主链</h3><p>在Byteball中，从任何一个顶端单元出发到达创世单元的最优路径称为<strong>候选主链（Candidate Mainchain）</strong>。最优路径通过选择最优父单元产生，选择策略用于保证整个网络的安全性。不同的候选主链会在某个单元位置交叉（最差的情况是在创世单元交叉），该交叉点称为<strong>稳定点（Stable Point）</strong>。对于所有候选主链，从稳定点到创世单元的路径完全相同，该路径称为<strong>稳定主链（Stable Mainchain）</strong>。稳定主链是一条确定的路径，从候选路径变为稳定主链是一个从不确定逐渐变成确定的过程。后续讨论中，如果没有明确区分，主链一般指的是候选主链。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2017-12-17-byteball-mainchain.png" alt="主链"></p>
<p>DAG中的每个单元要么直接位于主链上，要么经过较短的路径就能到达主链，主链可以形象地看作是一条连接着许多侧面道路的高速公路。一个单元一旦进入DAG中，它所在的主链也相应确定，因为后续单元只能作为其子单元，而无法更改其父单元。</p>
<p>给定一条主链，与之相关的所有单元均可以在此基础上进行排序，其序号称为<strong>主链序号（MCI, Main Chain Index）</strong>。创世单元的MCI为0，依次加1直到链尾。对于不在主链上的单元，其MCI等于主链上最先包含（直接或者间接）该单元的那个单元的MCI。MCI代表了从主链视角来看单元在DAG中的总序，对于发生冲突的双花交易，MCI较小的单元为有效单元。</p>
<h3 id="最优父单元的选择策略"><a href="#最优父单元的选择策略" class="headerlink" title="最优父单元的选择策略"></a>最优父单元的选择策略</h3><blockquote>
<p><strong>单元级别：</strong>由当前单元出发至创世单元的最长路径长度定义为单元级别（unit level）</p>
<p><strong>见证级别：</strong>从当前单元开始沿主链回溯，并对路径中不同见证人进行计数（相同见证人只计数1次），当遇到的见证人数足够多时（超过大多数的已知见证人）停止回溯；然后计算停止位置的单元级别，将其称作当前单元的见证级别（witnessed level）。</p>
</blockquote>
<p>最优父单元的选择策略由以下三部分组成：</p>
<ol>
<li>在选择最优父单元时，见证级别最高的父单元为最优父单元；</li>
<li>如果见证级别相同，则单元级别最低的作为最优父单元；</li>
<li>如果两者都相同，则选择单元哈希值（base64编码）更小的作为最优父单元。​</li>
</ol>
<p>那么，从顶端单元出发，只需要递归地在其父单元中选取最优父单元即可形成主链。在上述选择策略中，见证人成为了某个单元看待历史的视角，每个单元可以维护自己的见证人列表，也可以通过<code>witness_list_unit</code>引用其它单元的见证人列表。</p>
<blockquote>
<p><strong>单元兼容：</strong>如果两个单元的见证人列表差别最多一项，则称这两个单元兼容</p>
</blockquote>
<p>在选择最优父单元时，仅可以从与当前单元兼容的父单元中进行选择，以保证看待历史视角的连续性。不兼容的父单元仍然被承认，但是他们不能成为最优父单元。特别地，在发出新单元时，如果与所有顶端单元都不兼容，则应从上一级别的父单元中进行选择。</p>
<h3 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h3><p>在用户地址发出新单元时，要求相同地址发布的所有单元应当直接或间接包含该地址之前所有的单元，即相同地址的所有单元连通（有序或连续）。</p>
<blockquote>
<p><strong>双花交易：</strong>相同地址发出的任何无序的交易都视为双花交易，即使它们没有使用相同的输出，也可称为冲突交易或者矛盾交易。</p>
</blockquote>
<p>因此，在相同地址的所有单元都连通的情况下，在路径上出现较早的交易为有效交易。如果有攻击者特意制造出双花交易，那么可以通过主链序号来解决，主链序号较小的交易为有效交易。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2017-12-17-byteball-double-spend-1.png" alt="双花交易"></p>
<p>上图给出了一种攻击场景，攻击者制造出一条影子链，并在上面发布双花交易。当影子链接入到真实的DAG中时，根据最优父单元选择策略，影子链上的见证人个数少，因此它不会成为主链的一部分，从而解决了这种场景下的双花问题。<strong>值得注意的是，如果大多数见证人与攻击者合谋，并在其影子链上发布单元，则攻击者有可能攻击成功。</strong></p>
<h3 id="单元成为稳定点的条件"><a href="#单元成为稳定点的条件" class="headerlink" title="单元成为稳定点的条件"></a>单元成为稳定点的条件</h3><p>根据上面的分析可知，所有候选主链在稳定点之后到达创世单元的路径完全相同，即稳定主链成为最终状态。这也意味着，从稳定主链上单元直接或间接包含的那些单元也将无法再被篡改。因此，只要随着新单元的不断加入，稳定点可以不断地向后扩展，且不同的用户节点的稳定点扩展方式保持一致，则全网的所有用户节点可以<strong>实现共识</strong>。</p>
<p>对于所有单元，如果只保留其与其最优父单元的连接，则DAG将退化为一棵树$T$，所有的候选主链只可能从这棵树中产生。下面根据稳定点是否具有多个子单元分两种情况对稳定点的扩展方式进行讨论。</p>
<blockquote>
<p><strong>当前主链：</strong>在DAG中，从不同顶端单元出发具有不同的候选主链，从见证级别最高的顶端节点出发的候选主链称为当前主链（Current Mainchain）。</p>
</blockquote>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2017-12-18-byteball-tree1.png" alt="稳定点不分叉"></p>
<p>假设当前稳定点的见证人列表为$W$，单元级别为$l$，它只有一个子单元，如上图所示。以$W$作为见证人列表，从当前主链的顶端节点进行回溯，直到遇见$W$中的大部分见证人，记录这些见证人发出的单元中的最小见证级别，记作$min_wl$。如果$min_wl&gt;l$，则扩展当前稳定点至其子单元，否则不进行扩展。由于大部分见证人已经在当前主链上了，后续这些见证人发布的单元将继续支持当前路径，从而使得稳定点可以向前扩展。</p>
<p><img src="http://oc7urqs4c.bkt.clouddn.com/2017-12-18-byteball-tree2.png" alt="稳定点分叉"></p>
<p>假设当前稳定点具有多个子单元，如上图所示。在当前稳定点的所有子单元中（除了位于当前主链的子单元），找出见证级别大于当前稳定点的子单元，并将其中最大的单元级别记为$max_l$。也就是说，除了当前主链外，当前稳定点其它分支上的单元见证级别将不超过$max_l$。如果$min_wl&gt;max_l$，那么稳定点可以沿当前主链向前扩展。</p>
<p>随着稳定点的不断前进，稳定主链及其相关单元的状态被最终确定下来。只要DAG中的单元相同，其形成的主链和稳定点也是相同的。因此，不同的用户节点，只要最终收到相同的单元，它们最终将达到一致的状态。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="guantau" />
          <p class="site-author-name" itemprop="name">guantau</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/guantau" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guantau</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"guantau"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_SVG"></script>


  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("FJnjyRtFhXhHRSFrytdeIeeV-gzGzoHsz", "fzauUFb059QQVrhlExPYprHH");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
